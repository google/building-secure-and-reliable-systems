<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Building Secure and Reliable Systems</title>
  <link rel="stylesheet" type="text/css" href="theme/html/html.css">
</head>
<body data-type="book">
<section xmlns="http://www.w3.org/1999/xhtml" data-type="chapter" id="writing_code">
<h1>Writing Code</h1>

<p class="byline">By Michał Czapiński and Julian Bangert</p>
<p class="byline cont">with Thomas Maufer and Kavita Guliani</p>

<aside data-type="sidebar" id="code_will_inevitably_include_bugsdot_ho">
<p><a contenteditable="false" data-primary="writing code" data-type="indexterm" id="ch12.html0">&nbsp;</a>Code will inevitably include bugs. However, you can avoid common security vulnerabilities and reliability issues by using hardened frameworks and libraries designed to be resilient against these problem classes.</p>
<p>This chapter presents software development patterns that should be applied during the implementation of a project. We start by looking at an RPC backend example and exploring how frameworks help us automatically enforce desired security properties and mitigate typical reliability anti-patterns. We also focus on code simplicity, which is achieved by controlling the accumulation of technical debt and refactoring the codebase when needed. We conclude with tips on how to select the right tools and make the most of your chosen development languages.</p>
</aside>
<p>Security and reliability cannot easily be retrofitted into software, so it’s important to account for them in software design from the earliest phases. Tacking on these features after a launch is painful and less effective, and may require you to change other fundamental assumptions about the codebase (see <a data-type="xref" href='ch04.html#design_tradeoffs'>Chapter 4</a> for a deeper discussion on this topic).</p>
<p>The first and most important step in reducing security and reliability issues is to educate developers. However, even the best-trained engineers make mistakes—security experts can write insecure code and SREs can miss reliability issues. It’s difficult to keep the many considerations and tradeoffs involved in building secure and reliable systems in mind simultaneously, especially if you’re also responsible for producing software.</p>
<p>Instead of relying solely on developers to vet code for security and reliability, you can task SREs and security experts with reviewing code and software designs. This approach is also imperfect—manual code reviews won’t find every issue, and no reviewer will catch <em>every</em> security problem that an attacker could potentially exploit. Reviewers can also be biased by their own experience or interests. For example, they may naturally gravitate toward seeking out new classes of attacks, high-level design issues, or interesting flaws in cryptographic protocols; in contrast, reviewing hundreds of HTML templates for cross-site scripting (XSS) flaws or checking the error-handling logic for each RPC in an application may be seen as less thrilling.</p>
<p>While code reviews may not find every vulnerability, they do have other benefits. A strong review culture encourages developers to structure their code in a way that makes the security and reliability properties easy to review. This chapter discusses strategies for making these properties obvious to reviewers and for integrating automation into the development process. These strategies can free up a team’s bandwidth to focus on other issues and lead to building a culture of security and reliability (see <a data-type="xref" href='ch21.html#twoone_building_a_culture_of_security_a'>Chapter 21</a>).</p>
<section data-type="sect1" id="frameworks_to_enforce_security_and_reli">
<h1>Frameworks to Enforce Security and Reliability</h1>
<p><a contenteditable="false" data-primary="frameworks, software development" data-secondary="reliability/security enforcement" data-type="indexterm" id="ch12.html1">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="frameworks to enforce security and reliability" data-type="indexterm" id="ch12.html2">&nbsp;</a>As discussed in <a data-type="xref" href='ch06.html#design_for_understandability'>Chapter 6</a>, the security and reliability of an application rely on domain-specific invariants. For example, an application is secure against SQL injection attacks if all of its database queries consist only of developer-controlled code, with external inputs supplied via query parameter bindings. A web application can prevent XSS attacks if all user input that’s inserted into HTML forms is properly escaped or sanitized to remove any executable code.</p>
<aside data-type="sidebar" id="common_security_and_reliability_invaria">
<h5>Common Security and Reliability Invariants</h5>
<p><a contenteditable="false" data-primary="invariants" data-secondary="common security invariants" data-type="indexterm" id="ch12.html_ix1">&nbsp;</a>Almost any multiuser application has application-specific security invariants that govern which users can perform which actions on data; every action should consistently maintain these invariants. To prevent cascading failures in a distributed system, each application must also follow reasonable policies, such as backing off retries on failing RPCs. Similarly, in order to avoid memory corruption crashes and security issues, C++ programs should access only valid memory locations.</p>
</aside>
<p>In theory, you can create secure and reliable software by carefully writing application code that maintains these invariants. However, as the number of desired properties and the size of the codebase grows, this approach becomes almost impossible. It’s unreasonable to expect any developer to be an expert in all these subjects, or to constantly maintain vigilance when writing or reviewing code.</p>
<p>If humans need to manually review every change, those humans will have a hard time maintaining global invariants because reviewers can’t always keep track of global context. If a reviewer needs to know which function parameters are passed user input by callers and which arguments only contain developer-controlled, trustworthy values, they must also be familiar with all transitive callers of a function. Reviewers are unlikely to be able to keep this state over the long run.</p>
<p>A better approach is to handle security and reliability in common frameworks, languages, and libraries. Ideally, libraries only expose an interface that makes writing code with common classes of security vulnerabilities impossible. Multiple applications can use each library or framework. When domain experts fix an issue, they remove it from all the applications the framework supports, allowing this engineering approach to scale better. Compared to manual review, using a centralized hardened framework also reduces the chances of future vulnerabilities creeping in. Of course, no framework can protect against all security vulnerabilities, and it is still possible for attackers to discover an unforeseen class of attacks or find mistakes in the implementation of the framework. But if you discover a new vulnerability, you can address it in one place (or a few) instead of throughout the codebase.</p>
<p><a contenteditable="false" data-primary="SQL injection (SQLI)" data-type="indexterm" id="ch12.html_ix2">&nbsp;</a>To provide one concrete example: SQL injection (SQLI) holds the top spot on both the <a href="https://www.owasp.org/images/7/72/OWASP_Top_10-2017_(en).pdf.pdf">OWASP</a> and <a href="https://www.sans.org/top25-software-errors">SANS</a> lists of common security vulnerabilities. In our experience, when you use a hardened data library such as <code>TrustedSqlString</code> (see <a data-type="xref" href='#sql_injection_vulnerabilities_trustedsq'>SQL Injection Vulnerabilities: TrustedSqlString</a>), these types of vulnerabilities become a nonissue. Types make these assumptions explicit, and are automatically enforced by the compiler.</p>
<section data-type="sect2" id="benefits_of_using_frameworks">
<h2>Benefits of Using Frameworks</h2>
<p><a contenteditable="false" data-primary="frameworks, software development" data-secondary="benefits of" data-type="indexterm" id="ch12.html_ix3">&nbsp;</a>Most applications have similar building blocks for security (authentication and authorization, logging, data encryption) and reliability (rate limiting, load balancing, retry logic). Developing and maintaining such building blocks from scratch for every service is expensive, and leads to a patchwork of different bugs in each service.</p>
<p>Frameworks enable code reuse: rather than accounting for all of the security and reliability aspects affecting a given functionality or feature, developers only need to customize a specific building block. For example, a developer can specify which information from the incoming request credentials is important for authorization without worrying about the credibility of that information—that credibility is verified by the framework. Equally, a developer can specify which data needs to be logged without worrying about storage or replication. Frameworks also make propagating updates easier, as you need to apply an update in only one location.</p>
<p>Using frameworks leads to increased productivity for all developers in an organization, a benefit for building a culture of security and reliability (see <a data-type="xref" href='ch21.html#twoone_building_a_culture_of_security_a'>Chapter 21</a>). It’s much more efficient for a team of domain experts to design and develop the <span class="keep-together">framework</span> building blocks than for each individual team to implement security and reliability features itself. For example, if the security team handles cryptography, all other teams benefit from their knowledge. None of the developers using the frameworks need to worry about their internal details, and they can instead focus on an application’s business logic.</p>
<p>Frameworks further increase productivity by providing tools that are easy to integrate with. For example, frameworks can provide tools that automatically export basic operational metrics, like the total number of requests, the number of failed requests broken down by error type, or the latency of each processing stage. You can use that data to generate automated monitoring dashboards and alerting for a service. Frameworks also make integrating with load-balancing infrastructure easier, so a service can automatically redirect traffic away from overloaded instances, or spin up new service instances under heavy load. As a result, services built on top of frameworks exhibit significantly higher reliability.</p>
<p>Using frameworks also makes reasoning about the code easy by clearly separating business logic from common functions. This enables developers to make assertions about the security or reliability of a service with more confidence. In general, frameworks lead to reduced complexity—when code across multiple services is more uniform, it’s easier to follow common good practices.</p>
<p>It doesn’t always make sense to develop your own frameworks. In many cases, the best strategy is to reuse existing solutions. For example, almost any security professional will advise you against designing and implementing your own cryptographic framework—instead, you might use a well-established and widely used framework such as Tink (discussed in <a data-type="xref" href='ch06.html#example_secure_cryptographic_apis_and_t'>Example: Secure cryptographic APIs and the Tink crypto framework</a>).</p>
<p>Before deciding to adopt any specific framework, it’s important to evaluate its security posture. We also suggest using actively maintained frameworks and continuously updating your code dependencies to incorporate the latest security fixes for any code on which your code depends.</p>
<p>The following case study is a practical example demonstrating the benefits of frameworks: in this case, a framework for creating RPC backends.</p>
</section>
<section data-type="sect2" class="pagebreak-before" id="example_framework_for_rpc_backends">
<h2 class="less_space">Example: Framework for RPC Backends</h2>
<p><a contenteditable="false" data-primary="frameworks, software development" data-secondary="RPC backends" data-type="indexterm" id="ch12.html3">&nbsp;</a><a contenteditable="false" data-primary="remote procedure calls (RPCs)" data-secondary="framework for backends" data-type="indexterm" id="ch12.html4">&nbsp;</a>Most RPC backends follow a similar structure. They handle request-specific logic and typically also perform the following:</p>
<ul>
<li><p>Logging</p></li>
<li><p>Authentication</p></li>
<li><p>Authorization</p></li>
<li><p>Throttling (rate limiting)</p></li>
</ul>
<p>Instead of reimplementing this functionality for every single RPC backend, we recommend using a framework that can hide the implementation details of these building blocks. Then developers just need to customize each step to accommodate their service’s needs.</p>
<p><a data-type="xref" href="#a_control_flow_in_a_potential_framework">Figure 12-1</a> presents a possible framework architecture based on predefined <em>interceptors</em> that are responsible for each of the previously mentioned steps. You can potentially also use interceptors for custom steps. Each interceptor defines an action to be performed <em>before</em> and <em>after</em> the actual RPC logic executes. Each stage can report an error condition, which prevents further interceptors from executing. However, when this occurs, the <em>after</em> steps of each interceptor that has already been called are executed in the reverse order. The framework between the interceptors can transparently perform additional actions—for example, exporting error rates or performance metrics. This architecture leads to a clear separation of the logic performed at every stage, resulting in increased simplicity and reliability.</p>
<figure id="a_control_flow_in_a_potential_framework">
<img src="images/bsrs_1201.png" alt="Figure 12-1: A control flow in a potential framework for RPC backends; the typical steps are encapsulated in predefined interceptors and authorization is highlighted as an example"/>
<figcaption>Figure 12-1: A control flow in a potential framework for RPC backends: the typical steps are encapsulated in predefined interceptors and authorization is highlighted as an example</figcaption>
</figure>
<p>In this example, the <em>before</em> stage of the logging interceptor could log the call, and the <em>after</em> stage could log the status of the operation. Now, if the request is unauthorized, the RPC logic doesn’t execute, but the “permission denied” error is properly logged. Afterward, the system calls the authentication and logging interceptors’ <em>after</em> stages (even if they are empty), and only then does it send the error to the client.</p>
<p>Interceptors share state through a <em>context object</em> that they pass to each other. For example, the authentication interceptor’s <em>before</em> stage can handle all the cryptographic operations associated with certificate handling (note the increased security from reusing a specialized crypto library rather than reimplementing one yourself). The system then wraps the extracted and validated information about the caller in a convenience object, which it adds to the context. Subsequent interceptors can easily access this object.</p>
<p>The framework can then use the context object to track request execution time. If at any stage it becomes obvious that the request won’t complete before the deadline, the system can automatically cancel the request. You can increase service reliability by notifying the client quickly, which also conserves resources.</p>
<p>A good framework should also enable you to work with dependencies of the RPC backend—for example, another backend that’s responsible for storing logs. You might register these as either soft or hard dependencies, and the framework can constantly monitor their availability. When it detects the unavailability of a hard dependency, the framework can stop the service, report itself as unavailable, and automatically redirect traffic to other instances.</p>
<p>Sooner or later, overload, network issues, or some other issue will result in a dependency being unavailable. In many cases, it would be reasonable to retry the request, but implement retries carefully in order to avoid a <em>cascading failure</em> (akin to falling dominoes).<sup><a data-type="noteref" id="ch12fn1-marker" href="#ch12fn1">1</a></sup> <a contenteditable="false" data-primary="exponential backoff" data-type="indexterm" id="ch12.html_ix4">&nbsp;</a>The most common solution is to retry with an <em>exponential backoff</em>.<sup><a data-type="noteref" id="ch12fn2-marker" href="#ch12fn2">2</a></sup> A good framework should provide support for such logic, rather than requiring the developer to implement the logic for every RPC call.</p>
<p>A framework that gracefully handles unavailable dependencies and redirects traffic to avoid overloading the service or its dependencies naturally improves the reliability of both the service itself and the entire ecosystem. These improvements require minimal involvement from developers.</p>
<section data-type="sect3" id="example_code_snippets">
<h3>Example code snippets</h3>
<p>Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#example_onetwo_onedot_initial_type_defi">example_onetwo_onedot_initial_type_defi</a> through <a data-type="xref" data-xrefstyle="select:labelnumber" href="#example_onetwo_threedot_example_logging">example_onetwo_threedot_example_logging</a> demonstrate the RPC backend developer’s perspective of working with a security- or reliability-focused framework. The examples are in Go and use <a href="https://developers.google.com/protocol-buffers/">Google Protocol Buffers</a><a contenteditable="false" data-primary="" id="ch12.html4-eot" data-startref="ch12.html4" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="" id="ch12.html3-eot" data-startref="ch12.html3" data-type="indexterm">&nbsp;</a>.<a contenteditable="false" data-primary="" id="ch12.html2-eot" data-startref="ch12.html2" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="" id="ch12.html1-eot" data-startref="ch12.html1" data-type="indexterm">&nbsp;</a></p>
<div data-type="example" id="example_onetwo_onedot_initial_type_defi">
<h5>Initial type definitions (the before stage of an interceptor can modify the context; for example, the authentication interceptor can add verified information about the caller)</h5>
<pre data-type="programlisting"><strong><span>type</span></strong> Request <strong><span>struct</span></strong> <span>{</span><span>
 </span> Payload <span>proto</span><span>.</span>Message<span>
</span><span>}</span><span>

<strong>type</strong></span> Response <strong><span>struct</span></strong> <span>{</span><span>
 </span> Err <span>error
 </span> Payload <span>proto</span><span>.</span>Message<span>
</span><span>}</span><span>

<strong>type</strong></span> Interceptor <strong><span>interface</span></strong> <span>{</span><span>
 </span> Before<span>(</span><span>context</span><span>.</span>Context<span>,</span> <span>*</span>Request<span>)</span> <span>(</span><span>context</span><span>.</span>Context<span>,</span> <span>error</span><span>)</span><span>
 </span> After<span>(</span><span>context</span><span>.</span>Context<span>,</span> <span>*</span>Response<span>)</span> <span>error
</span><span>}</span><span>

<strong>type</strong></span> CallInfo <strong><span>struct</span></strong> <span>{</span><span>
 </span> User <strong><span>string</span></strong><span>
 </span> Host <strong><span>string</span></strong><span>
 </span> <span>...</span><span>
</span><span>}</span></pre>
</div>
<div data-type="example" id="example_onetwo_twodot_example_authoriza">
<h5>Example authorization interceptor that allows only requests from allowlisted users</h5>
<pre data-type="programlisting"><strong>type</strong> authzInterceptor <span><strong>struct</strong></span> <span>{</span>
<span>  allowedRoles</span> <span><strong>map</strong>[</span><span><strong>string</strong></span><span>]<strong>bool</strong></span>
<span>}</span>

<strong>func</strong> <span>(ai *</span>authzInterceptor<span>)</span> <span>Before</span><span>(</span>ctx context<span>.</span><span>Context</span><span>,</span> req <span>*</span><span>Request</span><span>)</span> <span>(</span>context<span>.</span><span>Context</span><span>,</span> error<span>)</span> <span>{</span>
  <em><span>// callInfo was populated by the framework.</span></em>
  callInfo<span>,</span> err <span>:=</span> <span>FromContext</span><span>(</span>ctx<span>)</span>
  <span><strong>if</strong></span> err <span>!=</span> <span><strong>nil</strong></span> <span>{</span> <span><strong>return</strong></span> ctx<span>,</span> err <span>}</span>

  <span><strong>if</strong></span> ai.allowedRoles[callInfo<span>.</span><span>User]</span> <span>{</span> <span><strong>return</strong></span> ctx<span>,</span> <span><strong>nil</strong></span> <span>}</span>
  <span><strong>return</strong></span> ctx<span>,</span> fmt<span>.</span><span>Errorf</span><span>(</span><span>"Unauthorized request from %q"</span><span>,</span> callInfo<span>.</span><span>User</span><span>)</span>
<span>}</span>

<strong>func</strong> <span>(*</span>authzInterceptor<span>)</span> <span>After</span><span>(</span>ctx context<span>.</span><span>Context</span><span>,</span> resp <span>*</span><span>Response</span><span>)</span> error <span>{</span>
  <span><strong>return</strong></span> <span><strong>nil</strong></span>  <em><span>// Nothing left to do here after the RPC is handled.</span></em>
<span>}</span></pre>
</div>
<div class="pagebreak-before" data-type="example" id="example_onetwo_threedot_example_logging">
<h5>Example logging interceptor that logs every incoming request (before stage) and then logs all the failed requests with their status (after stage); WithAttemptCount is a framework-provided RPC call option that implements exponential backoff</h5>
<pre data-type="programlisting"><strong>type</strong> logInterceptor <strong><span>struct</span></strong> <span>{</span>
  logger <span>*</span><span>LoggingBackendStub</span>
<span>}</span>

<strong>func</strong> <span>(*</span>logInterceptor<span>)</span> <span>Before</span><span>(</span>ctx context<span>.</span><span>Context</span><span>,</span>
                              req <span>*</span><span>Request</span><span>)</span> <span>(</span>context<span>.</span><span>Context</span><span>,</span> error<span>)</span> <span>{</span>
  <em><span>// callInfo was populated by the framework.</span></em>
  callInfo<span>,</span> err <span>:=</span> <span>FromContext</span><span>(</span>ctx<span>)</span>
  <strong><span>if</span></strong> err <span>!=</span> <span><strong>nil</strong></span> <span>{</span> <strong><span><strong>return</strong></span></strong> ctx<span>,</span> err <span>}</span>
  logReq <span>:=</span> <span>&amp;</span>pb<span>.</span><span>LogRequest</span><span>{</span>
    timestamp<span>:</span> time<span>.</span><span>Now</span><span>().</span><span>Unix</span><span>(),</span>
    user<span>:</span> callInfo<span>.</span><span>User</span><span>,</span>
    request<span>:</span> req<span>.</span><span>Payload</span><span>,</span>
  <span>}</span>
  resp<span>,</span> err <span>:=</span> logger<span>.</span><span>Log</span><span>(</span>ctx<span>,</span> logReq<span>,</span> <span>WithAttemptCount</span><span>(</span><span>3</span><span>))</span>
  <strong><span>return</span></strong> ctx<span>,</span> err
<span>}</span>

<strong>func</strong> <span>(*</span>logInterceptor<span>)</span> <span>After</span><span>(</span>ctx context<span>.</span><span>Context</span><span>,</span> resp <span>*</span><span>Response</span><span>)</span> error <span>{</span>
  <strong><span><strong>if</strong></span></strong> resp<span>.</span><span>Err</span> <span>==</span> <span><strong>nil</strong></span> <span>{</span> <strong><span>return</span></strong> <span><strong>nil</strong></span> <span>}</span>
  
  logErrorReq <span>:=</span> <span>&amp;</span>pb<span>.</span><span>LogErrorRequest</span><span>{</span>
    timestamp<span>:</span> time<span>.</span><span>Now</span><span>().</span><span>Unix</span><span>(),</span>
    error<span>:</span> resp<span>.</span><span>Err</span><span>.</span><span>Error</span><span>(),</span>
  <span>}</span>
  resp<span>,</span> err <span>:=</span> logger<span>.</span><span>LogError</span><span>(</span>ctx<span>,</span> logErrorReq<span>,</span> <span>WithAttemptCount</span><span>(</span><span>3</span><span>))</span>
  <strong><span>return</span></strong> err
<span>}</span></pre>
</div>
</section>
</section>
</section>
<section data-type="sect1" id="common_security_vulnerabilities">
<h1>Common Security Vulnerabilities</h1>
<p><a contenteditable="false" data-primary="writing code" data-secondary="common security vulnerabilities" data-type="indexterm" id="ch12.html5">&nbsp;</a>In large codebases, a handful of classes account for the majority of security vulnerabilities, despite ongoing efforts to educate developers and introduce code review. OWASP and SANS publish lists of common vulnerability classes. <a data-type="xref" href="#top_onezero_most_common_vulnerability_r">#top_onezero_most_common_vulnerability_r</a> lists the 10 most common vulnerability risks according to <a href="https://www.owasp.org/images/7/72/OWASP_Top_10-2017_(en).pdf.pdf">OWASP</a>, along with some potential approaches to mitigate each at a framework level.</p>
<table class="border pagebreak-before" id="top_onezero_most_common_vulnerability_r">
<caption>Top 10 most common vulnerability risks according to OWASP</caption>
<thead>
<tr>
<th>OWASP top 10 vulnerability</th>
<th>Framework hardening measures</th>
</tr>
</thead>
<tbody>
<tr>
<td>[SQL] Injection</td>
<td><code>TrustedSQLString</code> (see the following section).</td>
</tr>
<tr>
<td>Broken authentication</td>
<td>Require authentication using a well-tested mechanism like OAuth before routing a request to the application. (See <a data-type="xref" href='#example_framework_for_rpc_backends'>Example: Framework for RPC Backends</a>.)</td>
</tr>
<tr>
<td>Sensitive data exposure</td>
<td>Use distinct types (instead of strings) to store and handle sensitive data like credit card numbers. This approach can restrict serialization to prevent leaks and enforce appropriate encryption.<br/>Frameworks can additionally enforce transparent in-transit protection, like HTTPS with LetsEncrypt. Cryptographic APIs such as <a href="https://github.com/google/tink/blob/master/docs/KEY-MANAGEMENT.md">Tink</a> can encourage appropriate secret storage, such as loading keys from a cloud key management system instead of a configuration file.</td>
</tr>
<tr>
<td>XML external entities (XXE)</td>
<td>Use an XML parser without XXE enabled; ensure this risky feature is disabled in libraries that support it.<sup><a data-type="noteref" id="ch12fn3-marker" href="#ch12fn3">3</a></sup></td>
</tr>
<tr>
<td>Broken access control</td>
<td>This is a tricky problem, because it’s often application-specific. Use a framework that requires every request handler or RPC to have well-defined access control restrictions. If possible, pass end-user credentials to the backend, and enforce an access control policy in the backend.</td>
</tr>
<tr>
<td>Security misconfiguration</td>
<td>Use a technology stack that provides secure configurations by default and restricts or doesn’t allow risky configuration options. For example, use a web framework that does not print error information in production. Use a single flag to enable all debug features, and set up your deployment and monitoring infrastructure to ensure this flag is not enabled for public users. The <code>environment</code> flag in Rails is one example of this approach.</td>
</tr>
<tr>
<td>Cross-site scripting (XSS)</td>
<td>Use an XSS-hardened template system (see <a data-type="xref" href='#preventing_xss_safehtml'>Preventing XSS: SafeHtml</a>).</td>
</tr>
<tr>
<td>Insecure deserialization</td>
<td>Use deserialization libraries that are built for handling untrusted inputs, such as <a href="https://developers.google.com/protocol-buffers/">Protocol Buffers</a>.</td>
</tr>
<tr>
<td>Using components with known vulnerabilities</td>
<td>Choose libraries that are popular and actively maintained. Do not pick components that have a history of unfixed or slowly fixed security issues. Also see <a data-type="xref" href='#lessons_for_evaluating_and_building_fra'>Lessons for Evaluating and Building Frameworks</a>.</td>
</tr>
<tr>
<td>Insufficient logging &amp; monitoring</td>
<td>Instead of relying on ad hoc logging, log and monitor requests and other events as appropriate in a low-level library. See the logging interceptor described in the previous section for an example.</td>
</tr>
</tbody>
</table>
<section data-type="sect2" id="sql_injection_vulnerabilities_trustedsq">
<h2>SQL Injection Vulnerabilities: TrustedSqlString</h2>
<p><a contenteditable="false" data-primary="SQL injection (SQLI)" data-type="indexterm" id="ch12.html6">&nbsp;</a><a contenteditable="false" data-primary="TrustedSqlString" data-type="indexterm" id="ch12.html7">&nbsp;</a><a href="https://xkcd.com/327">SQL injection</a> is a common class of security vulnerability. When untrustworthy string fragments are inserted into a SQL query, attackers can potentially inject database commands. The following is a simple password reset web form:</p>
<pre data-type="programlisting">db<span>.</span>query<span>(</span>"UPDATE users SET pw_hash <span>=</span> <span>'" + request["pw_hash"] 
         + "'</span> WHERE reset_token <span>=</span> <span>'" + request.params["reset_token"] + "'")</span></pre>
<p>In this case, the user’s request is directed to a backend with an unguessable <code>reset_token</code> specific to their account. However, because of the string concatenation, a malicious user could craft a custom <code>reset_token</code> with extra SQL commands (such as <code>' or username='admin)</code> and <em>inject</em> this token into the backend. The result could reset the password hash of a different user—in this case, the admin account.</p>
<p>SQL injection vulnerabilities can be harder to spot in more complicated codebases. The database engine can help you prevent SQL injection vulnerabilities by providing bound parameters and prepared statements:</p>
<pre data-type="programlisting"><span>Query</span> <span>q</span> <span>=</span> <span>db</span><span>.</span><span>createQuery</span><span>(</span>
  "UPDATE users SET pw_hash = @hash WHERE token = @token");
q.setParameter("<span>hash</span>", request.params["<span>hash</span>"]);
q.setParameter("<span>token</span>", request.params["<span>token</span>"]);
db.query(q);</pre>
<p>However, merely establishing a guideline to use prepared statements does not result in a scalable security process. You would need to educate every developer about this rule, and security reviewers would have to review all application code to ensure consistent use of prepared statements. Instead, you can design the database API so that mixing user input and SQL becomes impossible by design. For example, you can create a separate type called <code>TrustedSqlString</code> and enforce by construction that all SQL query strings are created from developer-controlled input. In Go, you could implement the type as follows:</p>
<pre data-type="programlisting">struct <span>Query</span> <span>{</span>
 <span> sql strings</span><span>.</span><span>Builder</span><span>;</span>
<span>}</span> 
<span>type stringLiteral</span> string<span>;</span> <span/> 
<span><em>// Only call this function with string literal parameters.</em></span>
<span>func</span> <span>(</span><span>q</span> <span>*</span><span>Query</span><span>)</span> <span>AppendLiteral</span><span>(</span><span>literal stringLiteral</span><span>)</span> <span>{</span>
 <span> q</span><span>.</span><span>sql</span><span>.</span><span>writeString</span><span>(</span><span>literal</span><span>);</span>
<span>}</span>
<span><em>// q.AppendLiteral("foo") will work, q.AppendLiteral(foo) will not</em></span></pre>
<p>This implementation guarantees by construction that the contents of <code>q.sql</code> are entirely concatenated from string literals present in your source code, and the user cannot provide string literals. To enforce this contract at scale, you can use a language-specific mechanism to make sure <code>AppendLiteral</code> is called only with string literals. For example:</p>
<dl>
<dt>In Go</dt>
<dd>Use a package-private type alias (<code>stringLiteral</code>). Code outside the package cannot refer to this alias; however, string literals are implicitly converted to this type.</dd>
<dt>In Java</dt>
<dd>Use the <a href="https://errorprone.info">Error Prone</a> code checker, which provides a <code>@CompileTimeConstant</code> annotation for parameters.</dd>
<dt>In C++</dt>
<dd>Use a template constructor that depends on each character value in the string.</dd>
</dl>
<p>You can find similar mechanisms for other languages.</p>
<p>You can’t build some features—like a data analytics application that by design runs arbitrary SQL queries provided by the user who owns the data—using just compile-time constants. To handle complicated use cases, at Google we allow a way to bypass the type restrictions with approval from a security engineer. For example, our database API has a separate package, <code>unsafequery</code>, that exports a distinct <code>unsafequery.String</code> type, which can be constructed from arbitrary strings and appended to SQL queries. Only a small fraction of our queries use the unchecked APIs. The burden of reviewing new uses of SQL queries that are not inherently safe and other restricted API patterns is handled by one (rotating) engineer on a part-time basis, for hundreds to thousands of active developers. See <a data-type="xref" href='#lessons_for_evaluating_and_building_fra'>Lessons for Evaluating and Building Frameworks</a> for other benefits of reviewed exemptions.<a contenteditable="false" data-primary="" id="ch12.html7-eot" data-startref="ch12.html7" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="" id="ch12.html6-eot" data-startref="ch12.html6" data-type="indexterm">&nbsp;</a></p>
</section>
<section data-type="sect2" id="preventing_xss_safehtml">
<h2>Preventing XSS: SafeHtml</h2>
<p><a contenteditable="false" data-primary="cross-site scripting (XSS)" data-type="indexterm" id="ch12.html_ix5">&nbsp;</a><a contenteditable="false" data-primary="SafeHtml" data-type="indexterm" id="ch12.html_ix6">&nbsp;</a><a contenteditable="false" data-primary="XSS (cross-site scripting)" data-type="indexterm" id="ch12.html_ix7">&nbsp;</a>The type-based safety approach we described in the previous section is not specific to SQL injection. Google uses a more complex version of the same design to reduce cross-site scripting vulnerabilities in web applications.<sup><a data-type="noteref" id="ch12fn4-marker" href="#ch12fn4">4</a></sup></p>
<p>At their core, XSS vulnerabilities occur when a web application renders untrustworthy input without appropriate sanitization. For example, an application might interpolate an attacker-controlled <code>$address</code> value into an HTML snippet such as <code>&lt;div&gt;$address&lt;/div&gt;</code>, which is shown to another user. An attacker can then set <code>$address</code> to <code>&lt;script&gt;exfiltrate_user_data();&lt;/script&gt;</code> and execute arbitrary code in the context of another user’s page.</p>
<p>HTML does not have the equivalent of binding query parameters. Instead, untrustworthy values must be appropriately sanitized or escaped before they are inserted into an HTML page. Furthermore, different HTML attributes and elements have different semantics, so application developers have to treat values differently depending on the context in which they appear. For example, an attacker-controlled URL can cause code execution with the <code>javascript:</code> scheme.</p>
<p>A type system can capture these requirements by introducing different types for values meant for different contexts—for example, <code>SafeHtml</code> to represent the contents of an HTML element, and <code>SafeUrl</code> for URLs that are safe to navigate to. Each of the types is a (immutable) wrapper around a string; the contracts are upheld by the <span class="keep-together">constructors</span> available for each type. The constructors make up the trusted codebase that’s responsible for ensuring the security properties of the application.</p>
<p>Google has created different builder libraries for different use cases. Individual HTML elements can be constructed with builder methods that require the correct type for each attribute value, and <code>SafeHtml</code> for the element contents. The template system with strict contextual escaping guarantees the <code>SafeHtml</code> contract for more complicated HTML. That system does the following:</p>
<ol>
<li><p>Parses the partial HTML in the template</p></li>
<li><p>Determines the context for each substitution point</p></li>
<li><p>Either requires the program to pass in a value of the correct type, or correctly escapes or sanitizes untrusted string values</p></li>
</ol>
<p>For example, if you have the following Closure Template:</p>
<pre data-type="programlisting">{template .foo kind="html"}&lt;script src="{$url}"&gt;&lt;/script&gt;{/template}</pre>
<p>trying to use a string value for <code>$url</code> will fail:</p>
<pre data-type="programlisting">templateRendered.setMapData(ImmutableMap.of("url", some_variable));</pre>
<p>Instead, the developer has to provide a <code>TrustedResourceUrl</code> value, e.g.:</p>
<pre data-type="programlisting">templateRenderer<span>.</span>setMapData<span>(</span>
     <span>ImmutableMap</span><span>.</span>of<span>(</span><span>"x"</span><span>,</span> <span>TrustedResourceUrl</span><span>.</span>fromConstant<span>(</span><span>"/script.js"</span><span>))</span>
 <span>).</span>render<span>();</span></pre>
<p>If HTML originates from an untrusted source, you won’t want to embed it into your application’s web UI, since doing so would result in an easily exploitable XSS vulnerability. Instead, you can use an HTML sanitizer that parses the HTML and performs runtime checks to determine that each value meets its contract. The sanitizer removes elements that do not meet their contract, or elements for which it is impossible to check the contract at runtime. You can also use a sanitizer to interoperate with other systems that don’t use safe types, because many HTML fragments are unchanged by sanitization.</p>
<p>Different HTML construction libraries target different developer productivity and code readability tradeoffs. However, they all enforce the same contract and should be equally trustworthy (apart from any bugs in their trusted implementations). In fact, to reduce the maintenance burden at Google, we code-generate the builder functions in various languages from a declarative configuration file. This file lists HTML elements and the required contracts for the values of each attribute. Some of our HTML sanitizers and template systems use the same configuration file.</p>
<p>A mature open source implementation of safe types for HTML is available in <a href="https://github.com/google/closure-templates">Closure Templates</a>, and there is an effort underway to introduce <a href="https://github.com/w3c/webappsec-trusted-types">type-based security</a> as a web standard.<a contenteditable="false" data-primary="" id="ch12.html5-eot" data-startref="ch12.html5" data-type="indexterm">&nbsp;</a></p>
</section>
</section>
<section data-type="sect1" id="lessons_for_evaluating_and_building_fra">
<h1>Lessons for Evaluating and Building Frameworks</h1>
<p><a contenteditable="false" data-primary="frameworks, software development" data-secondary="lessons for evaluation/construction" data-type="indexterm" id="ch12.html8">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="lessons for framework evaluation/construction" data-type="indexterm" id="ch12.html9">&nbsp;</a>The previous sections discussed how to structure libraries to establish security and reliability properties. However, you can’t elegantly express all such properties with API design, and in some cases you can’t even change the API easily—for example, when interacting with the standardized DOM API exposed by a web browser.</p>
<p>Instead, you can introduce compile-time checks to prevent developers from using risky APIs. Plug-ins for popular compilers, such as <a href="https://errorprone.info">Error Prone</a> for Java and <a href="https://tsetse.info">Tsetse</a> for TypeScript, can prohibit risky code patterns.</p>
<p>Our experience has shown that compiler errors provide immediate and actionable feedback. Tools running on an opt-in basis (like linters) or at code review time provide feedback much later. By the time code is sent for review, developers usually have a finished, working unit of code. Learning that you need to perform some rearchitecting in order to use a strictly typed API that late in the development process can be frustrating.</p>
<p>It’s much easier to equip developers with compiler errors or faster feedback mechanisms like IDE plug-ins that underline problematic code. Typically, developers iterate through compilation issues quickly, and already have to fix other compiler diagnostics like trivial misspellings and syntactic errors. Because the developers are already working on the specific lines of code affected, they have full context, so making changes is easier—for example, changing the type of a string to <code>SafeHtml</code>.</p>
<p>You can improve the developer experience even further by suggesting automatic fixes that work as a starting point for a safe solution. For example, when you detect a call to a SQL query function, you can automatically insert a call to <code>TrustedSqlBuilder.fromConstant</code> with the query parameter. Even if the resulting code does not quite compile (perhaps because the query is a string variable and not a constant), developers know what to do, and don’t need to bother with the mechanical details of the API by finding the right function, adding the correct import declarations, and so on.</p>
<p>In our experience, as long as the feedback cycle is quick, and fixing each pattern is relatively easy, developers embrace inherently safe APIs much more readily—even when we can’t prove that their code was insecure, or when they do a good job of writing secure code using the unsafe APIs. Our experience contrasts with existing research literature, which focuses on reducing the false-positive and false-negative rates.<sup><a data-type="noteref" id="ch12fn5-marker" href="#ch12fn5">5</a></sup></p>
<p>We’ve found that focusing on those rates often results in complicated checkers that take much longer to produce findings. For example, a check might have to analyze whole-program data flows across a complicated application. It’s often difficult to explain how to remove the issue that the static analysis detects to developers, as the workings of the checker are much harder to explain than a simple syntactic property. Understanding a finding takes as much work as tracking down a bug in GDB (the GNU Debugger). On the other hand, fixing a type safety error at compile time while writing new code is usually not much harder than fixing a trivial type error.</p>
<section data-type="sect2" id="simplecomma_safecomma_reliable_librarie">
<h2>Simple, Safe, Reliable Libraries for Common Tasks</h2>
<p><a contenteditable="false" data-primary="frameworks, software development" data-secondary="simple, safe, reliable libraries for common tasks" data-type="indexterm" id="ch12.html_ix8">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="simple, safe, reliable libraries for common tasks" data-type="indexterm" id="ch12.html_ix9">&nbsp;</a>Building a safe library that covers all possible use cases and handles each reliably can be very challenging. For example, an application developer working on an HTML templating system might write the following template:</p>
<pre data-type="programlisting">&lt;a onclick="showUserProfile('{{username}}');"&gt;Show profile&lt;/a&gt;"&gt;</pre>
<p>To be XSS-proof, if <code>username</code> is attacker-controlled, the template system must nest three different layers of context: a single-quoted string, inside JavaScript, inside an attribute in an HTML element. Creating a template system that can handle all possible combinations of corner cases is complicated, and using that system won’t be straightforward. In other domains, this issue can grow even more complex. For example, business needs might dictate complex rules about who can perform an action and who cannot. Unless your authorization library is as expressive (and as hard to analyze) as a general-purpose programming language, you might not be able to meet all developer needs.</p>
<p>Instead, you can start with a simple, small library that covers only common use cases but is easier to use correctly. Simple libraries are easier to explain, document, and use. These qualities reduce developer friction and may help you convince other developers to adopt the secure-by-design library. In some cases, it might make sense to offer different libraries optimized for different use cases. For example, you might have both HTML templating systems for complicated pages and builder libraries for short snippets.</p>
<p>You can accommodate other use cases with expert-reviewed access to an unconstrained, risky library that bypasses safety guarantees. If you see repeated similar requests for a use case, you can support that feature in the inherently safe library. As we observed in <a data-type="xref" href='#sql_injection_vulnerabilities_trustedsq'>SQL Injection Vulnerabilities: TrustedSqlString</a>, the review load is usually manageable.</p>
<p>Because the volume of review requests is relatively small, security reviewers can look at the code in depth and  suggest extensive improvements—and the reviews tend to be unique use cases, which keeps reviewers motivated and prevents mistakes due to repetition and fatigue. Exemptions also act as a feedback mechanism: If developers repeatedly need exemptions for a use case, library authors should consider building a library for that use case.</p>
</section>
<section data-type="sect2" id="rollout_strategy">
<h2>Rollout Strategy</h2>
<p><a contenteditable="false" data-primary="frameworks, software development" data-secondary="rollout strategy" data-type="indexterm" id="ch12.html_ix10">&nbsp;</a><a contenteditable="false" data-primary="rollouts" data-secondary="strategy for" data-type="indexterm" id="ch12.html_ix11">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="rollout strategy" data-type="indexterm" id="ch12.html_ix12">&nbsp;</a>Our experience has shown that using types for security properties is very useful for new code. In fact, applications created in one widely used Google-internal web framework, which was developed from the outset with safe types for HTML, have had far fewer reported XSS vulnerabilities (by two orders of magnitude) than applications written without safe types, despite careful code review. The few reported vulnerabilities were caused by components of the application that did not use safe types.</p>
<p>It is more challenging to adapt existing code to use safe types. Even if you are starting with a brand new codebase, you need a strategy for migrating legacy code—you might discover new classes of security and reliability issues you want to protect against, or you might need to refine existing contracts.</p>
<p>We have experimented with several strategies for refactoring existing code; we discuss our two most successful approaches in the following subsections. These strategies require that you are able to access and modify the entire source code of your application. Most of Google’s source code is stored in a single repository<sup><a data-type="noteref" id="ch12fn6-marker" href="#ch12fn6">6</a></sup> with centralized processes for making, building, testing, and submitting changes. Code reviewers also enforce common readability and code organization standards, which reduces the complexity of changing an unfamiliar codebase. In other environments, large-scale refactorings can be more challenging. It helps to get broad agreement so every code owner is willing to accept changes to their source code, which contributes to the goal of building a culture of security and reliability.</p>
<div data-type="note">
<p><a contenteditable="false" data-primary="readability" data-type="indexterm" id="ch12.html_ix13">&nbsp;</a>Google’s company-wide style guide incorporates the concept of language <em>readability:</em> a certification that an engineer understands Google’s best practices and coding style for a given language. Readability ensures a baseline for code quality. An engineer must either have readability in the language they’re working with, or get a code review from someone with readability. For particularly complex or critically important code, in-person code reviews can be the most productive and effective way to improve your codebase’s quality.</p>
</div>
<section data-type="sect3" id="incremental_rollout">
<h3>Incremental rollout</h3>
<p><a contenteditable="false" data-primary="rollouts" data-secondary="incremental" data-type="indexterm" id="ch12.html_ix14">&nbsp;</a>Fixing the entire codebase at once is often not feasible. Different components might be in different repositories, and authoring, reviewing, testing, and submitting a single change that touches multiple applications is often brittle and error-prone. Instead, at Google, we initially exempt legacy code from enforcement, and address existing unsafe API users one by one.</p>
<p>For example, if you already have a database API with a <code>doQuery(String sql)</code> function, you could introduce an overload, <code>doQuery(TrustedSqlString sql)</code>, and restrict the unsafe version to existing callers. <a contenteditable="false" data-primary="Error Prone" data-type="indexterm" id="ch12.html_ix15">&nbsp;</a>Using the Error Prone framework, you can add a <code>@RestrictedApi(whitelistAnnotation={LegacyUnsafeStringQueryAllowed.class})</code> annotation and add the <code>@LegacyUnsafeStringQueryAllowed</code> annotation to all existing callers.</p>
<p>Then, by introducing <em>Git hooks</em> that analyze every commit, you can prevent new code from using the string-based overload. Alternatively, you can restrict the visibility of the unsafe API—for example, <a href="https://docs.bazel.build/versions/master/skylark/build-style.html#visibility">Bazel visibility allowlists</a> would allow a user to call the API only if a security team member approves the pull request (PR). If your codebase is under active development, it will organically move toward the safe API. After you reach the point at which only a small fraction of callers use the deprecated string-based API, you can manually clean up the remainder. At that point, your code will be immune to SQL injection by design.</p>
</section>
<section data-type="sect3" id="legacy_conversions">
<h3>Legacy conversions</h3>
<p><a contenteditable="false" data-primary="rollouts" data-secondary="legacy conversions" data-type="indexterm" id="ch12.html_ix16">&nbsp;</a>It is also often worthwhile to consolidate all of your exemption mechanisms into a single function that is obvious in the source code being read. For example, you can create a function that takes an arbitrary string and returns a safe type. You can use this function to replace all calls to string-typed APIs with more precisely typed calls. Typically, there will be a lot fewer types than functions consuming them. Instead of restricting and monitoring the removal of many legacy APIs (for example, every DOM API that consumes a URL), you have to remove only a single legacy conversion function per type.<a contenteditable="false" data-primary="" id="ch12.html9-eot" data-startref="ch12.html9" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="" id="ch12.html8-eot" data-startref="ch12.html8" data-type="indexterm">&nbsp;</a></p>
</section>
</section>
</section>
<section data-type="sect1" id="simplicity_leads_to_secure_and_reliable">
<h1>Simplicity Leads to Secure and Reliable Code</h1>
<p><a contenteditable="false" data-primary="writing code" data-secondary="simplicity&#39;s importance to" data-type="indexterm" id="ch12.html10">&nbsp;</a>Whenever practical, try to keep your code clean and simple. There are a number of publications on this topic,<sup><a data-type="noteref" id="ch12fn7-marker" href="#ch12fn7">7</a></sup> so here we focus on two lightweight stories that were published in the <a href="https://testing.googleblog.com">Google Testing Blog</a>. Both stories highlight strategies for avoiding quickly increasing codebase complexity.</p>
<section data-type="sect2" id="avoid_multilevel_nesting">
<h2>Avoid Multilevel Nesting</h2>
<p><a contenteditable="false" data-primary="multilevel nesting" data-type="indexterm" id="ch12.html_ix17">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="avoiding multilevel nesting" data-type="indexterm" id="ch12.html_ix18">&nbsp;</a>Multilevel nesting is a common anti-pattern that can lead to simple mistakes. If the error is in the most common code path, it will likely be captured by the unit tests. However, unit tests don’t always check error handling paths in multilevel nested code. The error might result in decreased reliability (for example, if the service crashes when it mishandles an error) or a security vulnerability (like a mishandled authorization check error).</p>
<p>Can you spot a bug in the code in <a data-type="xref" href="#errors_are_often_harder_to_spot_in_code">Figure 12-2</a>? The two versions are equivalent.<sup><a data-type="noteref" id="ch12fn8-marker" href="#ch12fn8">8</a></sup></p>
<figure id="errors_are_often_harder_to_spot_in_code">
<img src="images/bsrs_1202.png" alt="Figure 12-2: Errors are often harder to spot in code with multiple levels of nesting"/>
<figcaption>Figure 12-2: Errors are often harder to spot in code with multiple levels of nesting</figcaption>
</figure>
<p>The “wrong encoding” and “unauthorized” errors are swapped. This bug is easier to see in the refactored version because the checks occur as soon as the errors are <span class="keep-together">handled</span>.</p>
</section>
<section data-type="sect2" id="eliminate_yagni_smells">
<h2>Eliminate YAGNI Smells</h2>
<p><a contenteditable="false" data-primary="writing code" data-secondary="eliminating YAGNI smells" data-type="indexterm" id="ch12.html_ix19">&nbsp;</a><a contenteditable="false" data-primary="YAGNI (&quot;You Aren&#39;t Gonna Need It&quot;)" data-type="indexterm" id="ch12.html_ix20">&nbsp;</a>Sometimes developers overengineer solutions by adding functionality that may be useful in the future, “just in case.” This goes against the <a href="https://en.wikipedia.org/wiki/You_aren't_gonna_need_it">YAGNI (You Aren’t Gonna Need It) principle</a>, which recommends implementing only the code that you need. YAGNI code adds unnecessary complexity because it needs to be documented, tested, and maintained. Consider the following example:<sup><a data-type="noteref" id="ch12fn9-marker" href="#ch12fn9">9</a></sup></p>
<pre data-type="programlisting"><strong><span>class</span> <span>Mammal</span></strong> <span>{</span> <span>...</span>
  <strong><span>virtual</span></strong> <span>Status</span> <strong><span>Sleep</span></strong><span>(</span><strong><span>bool</span></strong> hibernate<span>)</span> <span>=</span> <span>0</span><span>;</span>
<span>};</span>
<strong><span>class</span> <span>Human</span></strong> <span>:</span> <strong><span>public</span></strong> <span>Mammal</span> <span>{</span> <span>...</span>
  <strong><span>virtual</span></strong> <span>Status</span> <strong><span>Sleep</span></strong><span>(</span><strong><span>bool</span></strong> hibernate<span>)</span> <span>{</span>
    age <span>+=</span> hibernate <span>?</span> kSevenMonths <span>:</span> kSevenHours<span>;</span>
    <strong><span>return</span></strong> OK<span>;</span>
  <span>}</span>
<span>};</span></pre>
<p>The <code>Human::Sleep</code> code must handle the case when <code>hibernate</code> is <code>true</code>, even though all callers should always pass <code>false</code>. In addition, callers must handle the returned status, even though that status should always be <code>OK</code>. Instead, until you need classes other than <code>Human</code>, this code can be simplified to the following:</p>
<pre data-type="programlisting"><strong><span>class</span> <span>Human</span></strong> <span>{</span> <span>...</span>
  <strong><span>void</span> <span>Sleep</span></strong><span>()</span> <span>{</span> age <span>+=</span> kSevenHours<span>;</span> <span>}</span>
<span>};</span></pre>
<p><a contenteditable="false" data-primary="incremental development and design" data-type="indexterm" id="ch12.html_ix21">&nbsp;</a>If the developer’s assumptions about possible requirements for future functionality are actually true, they can easily add that functionality later by following the principle of <em>incremental development and design</em>. In our example, it will be easier to create a <code>Mammal</code> interface with a better common API when we generalize based on several existing classes.</p>
<p>To summarize, avoiding YAGNI code leads to improved reliability, and simpler code leads to fewer security bugs, fewer opportunities to make mistakes, and less developer time spent maintaining unused code.</p>
</section>
<section data-type="sect2" id="repay_technical_debt">
<h2>Repay Technical Debt</h2>
<p><a contenteditable="false" data-primary="technical debt" data-secondary="repaying when writing code" data-type="indexterm" id="ch12.html_ix22">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="repaying technical debt" data-type="indexterm" id="ch12.html_ix23">&nbsp;</a>It is a common practice for developers to mark places that require further attention with TODO or FIXME annotations. In the short term, this habit can accelerate the delivery velocity for the most critical functionality, and allow a team to meet early deadlines—but it also incurs <em>technical debt</em>. Still, it’s not necessarily a bad practice, as long as you have a clear process (and allocate time) for repaying such debt.</p>
<p>Technical debt can include the erroneous handling of exceptional situations and the introduction of unnecessarily complex logic into the code (often written to work around other areas of technical debt). Either behavior can introduce security vulnerabilities and reliability issues that are rarely detected during testing (because of insufficient coverage of rare cases), and which consequently become part of the production environment.</p>
<p>You can deal with technical debt in many ways. For example:</p>
<ul>
<li><p>Keeping dashboards with code health metrics. These can range from simple dashboards that show test coverage or the number and average age of TODOs, to more sophisticated dashboards including metrics like <a href="https://www.perforce.com/blog/qac/what-cyclomatic-complexity"><em>cyclomatic complexity</em></a> or <a href="https://blogs.msdn.microsoft.com/zainnab/2011/05/26/code-metrics-maintainability-index/"><em>maintainability index</em></a>.</p></li>
<li><p>Using analysis tools like linters to detect common code defects such as dead code, unnecessary dependencies, or language-specific gotchas. Often, such tools can also automatically fix your code.</p></li>
<li><p>Creating notifications when code health metrics drop below predefined thresholds or when the number of automatically detected issues is too high.</p></li>
</ul>
<p>In addition, it’s important to maintain a team culture that embraces and focuses on good code health. Leadership can support this culture in many ways. For example, you can schedule regular <em>fixit</em> weeks during which developers focus on improving code health and fixing outstanding bugs rather than adding new functionality. You can also support continuous contributions to code health within the team with bonuses or other forms of recognition.</p>
</section>
<section data-type="sect2" id="refactoring">
<h2>Refactoring</h2>
<p><a contenteditable="false" data-primary="refactoring" data-type="indexterm" id="ch12.html_ix24">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="refactoring" data-type="indexterm" id="ch12.html_ix25">&nbsp;</a><em>Refactoring</em> is the most effective way to keep a codebase clean and simple. Even a healthy codebase occasionally needs to be refactored when you extend the existing feature set, change the backend, and so on.</p>
<p>Refactoring is particularly useful when working with old, inherited codebases. The first step of refactoring is measuring code coverage and increasing that coverage to a sufficient level.<sup><a data-type="noteref" id="ch12fn10-marker" href="#ch12fn10">10</a></sup> In general, the higher the coverage, the higher your confidence in the safety of refactoring. Unfortunately, even 100% test coverage can’t guarantee success, because the tests may not be meaningful. You can address this issue with other kinds of testing, such as <em>fuzzing,</em> which is covered in <a data-type="xref" href='ch13.html#onethree_testing_code'>Chapter 13</a>.</p>
<div data-type="note">
<p>Regardless of the reasons behind refactoring, you should always follow one golden rule: <em>never mix refactoring and functional changes in a single commit to the code repository</em>. Refactoring changes are typically significant and can be difficult to understand. If a commit also includes functional changes, there’s a higher risk that an author or reviewer might overlook bugs.</p>
</div>
<p>A complete overview of refactoring techniques is beyond the scope of this book. For more on this topic, see Martin Fowler’s excellent book<sup><a data-type="noteref" id="ch12fn11-marker" href="#ch12fn11">11</a></sup> and the discussions of <span class="keep-together">tooling</span> for automated, large-scale refactorings provided by Wright et al. (2013),<sup><a data-type="noteref" id="ch12fn12-marker" href="#ch12fn12">12</a></sup> Wasserman (2013),<sup><a data-type="noteref" id="ch12fn13-marker" href="#ch12fn13">13</a></sup> and Potvin and Levenberg (2016).<a contenteditable="false" data-primary="" id="ch12.html10-eot" data-startref="ch12.html10" data-type="indexterm">&nbsp;</a></p>
</section>
</section>
<section data-type="sect1" id="security_and_reliability_by_default">
<h1>Security and Reliability by Default</h1>
<p><a contenteditable="false" data-primary="writing code" data-secondary="security and reliability by default" data-type="indexterm" id="ch12.html11">&nbsp;</a>In addition to using frameworks with strong guarantees, you can use several other techniques to automatically improve the security and reliability posture of your application, as well as that of your team culture, which you’ll read more about in <a data-type="xref" href='ch21.html#twoone_building_a_culture_of_security_a'>Chapter 21</a>.</p>
<section data-type="sect2" id="choose_the_right_tools">
<h2>Choose the Right Tools</h2>
<p><a contenteditable="false" data-primary="writing code" data-secondary="choice of tools for" data-type="indexterm" id="ch12.html12">&nbsp;</a>Choosing a language, framework, and libraries is a complicated task that’s often influenced by a combination of factors, such as these:</p>
<ul>
<li><p>Integration with the existing codebase</p></li>
<li><p>Availability of libraries</p></li>
<li><p>Skills or preferences of the developer team</p></li>
</ul>
<p>Be aware of the enormous impact that language choice can have on the security and reliability of the project.</p>
<section data-type="sect3" id="use_memory_safe_languages">
<h3>Use memory-safe languages</h3>
<p><a contenteditable="false" data-primary="memory-safe languages" data-type="indexterm" id="ch12.html_ix26">&nbsp;</a><a contenteditable="false" data-primary="Miller, Matt" data-type="indexterm" id="ch12.html_ix27">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="memory-safe languages for" data-type="indexterm" id="ch12.html_ix28">&nbsp;</a>At BlueHat Israel in February 2019, Microsoft’s Matt Miller claimed that around 70% of all security vulnerabilities are due to memory safety issues.<sup><a data-type="noteref" id="ch12fn14-marker" href="#ch12fn14">14</a></sup> This statistic has remained consistent over at least the last 12 years.</p>
<p><a contenteditable="false" data-primary="Android" data-type="indexterm" id="ch12.html_ix29">&nbsp;</a><a contenteditable="false" data-primary="Kralevich, Nick" data-type="indexterm" id="ch12.html_ix30">&nbsp;</a>In a 2016 presentation, Nick Kralevich from Google reported that 85% of all bugs in Android (including bugs in the kernel and other components) were caused by memory management errors (slide 54).<sup><a data-type="noteref" id="ch12fn15-marker" href="#ch12fn15">15</a></sup> Kralevich concluded that “we need to move towards memory safe languages.” By using any language with higher-level memory management (such as Java or Go) rather than a language with more memory allocation difficulties (like C/C++), you can avoid this entire  class of security (and reliability) vulnerabilities by default. Alternatively, you can use code sanitizers that detect most memory management pitfalls (see <a data-type="xref" href='#sanitize_your_code'>Sanitize Your Code</a>).</p>
</section>
<section data-type="sect3" id="use_strong_typing_and_static_type_check">
<h3>Use strong typing and static type checking</h3>
<p><a contenteditable="false" data-primary="strongly typed language" data-type="indexterm" id="ch12.html_ix31">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="static type checking for" data-type="indexterm" id="ch12.html_ix32">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="strong typing for" data-type="indexterm" id="ch12.html_ix33">&nbsp;</a>In a <em>strongly typed</em> language, “whenever an object is passed from a calling function to a called function, its type must be compatible with the type declared in the called function.”<sup><a data-type="noteref" id="ch12fn16-marker" href="#ch12fn16">16</a></sup> A language without that requirement is referred to as <em>weakly</em> or <em>loosely typed</em>. <a contenteditable="false" data-primary="dynamic type checking" data-type="indexterm" id="ch12.html_ix34">&nbsp;</a><a contenteditable="false" data-primary="static type checking" data-type="indexterm" id="ch12.html_ix35">&nbsp;</a><a contenteditable="false" data-primary="type checking" data-type="indexterm" id="ch12.html_ix36">&nbsp;</a>You can enforce type checking either during compilation (<em>static type checking</em>) or at runtime (<em>dynamic type checking</em>).</p>
<p>The benefits of strong typing and static type checking are especially noticeable when working on large codebases with multiple developers, as you can enforce invariants and eliminate a wide range of errors at compilation time rather than at runtime. This leads to more reliable systems, fewer security issues, and better-performing code in a production environment.</p>
<p>In contrast, when using dynamic type checking (for example, in Python), you can infer almost nothing about the code unless it has 100% test coverage—which is great in principle, but rarely observed in practice. Reasoning about the code becomes even harder in weakly typed languages, often leading to surprising behavior. For example, in JavaScript, every literal is by default treated as a string: <code>[9, 8, 10].sort() -&gt; [10, 8, 9]</code>.<sup><a data-type="noteref" id="ch12fn17-marker" href="#ch12fn17">17</a></sup> In both of these cases, because invariants aren’t enforced at compilation time, you can only capture mistakes during testing. In consequence, you more often detect reliability and security issues, especially in less frequently exercised code paths, in the production environment rather than during development.</p>
<p>If you want to use languages that have dynamic type checking or weak typing by default, we recommend using extensions like the following to improve the reliability of your code. These extensions offer support for stricter type checking, and you can incrementally add them to existing codebases:</p>
<ul>
<li><p><a href="https://opensource.google.com/projects/pytype">Pytype for Python</a></p></li>
<li><p><a href="https://www.typescriptlang.org">TypeScript for JavaScript</a><a contenteditable="false" data-primary="" id="ch12.html12-eot" data-startref="ch12.html12" data-type="indexterm">&nbsp;</a></p></li>
</ul>
</section>
</section>
<section data-type="sect2" id="use_strong_types">
<h2>Use Strong Types</h2>
<p><a contenteditable="false" data-primary="strongly typed language" data-type="indexterm" id="ch12.html13">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="strong typing for" data-type="indexterm" id="ch12.html14">&nbsp;</a>Using untyped primitives (such as strings or integers) can lead to the following issues:</p>
<ul>
<li><p>Passing conceptually invalid parameters to a function</p></li>
<li><p>Unwanted implicit type conversions</p></li>
<li><p>Difficult-to-understand type hierarchy<sup><a data-type="noteref" id="ch12fn18-marker" href="#ch12fn18">18</a></sup></p></li>
<li><p>Confusing measurement units</p></li>
</ul>
<p>The first situation—passing conceptually invalid parameters to a function—occurs if the primitive type of a function parameter does not have enough context, and therefore becomes confusing when it’s called. For example:</p>
<ul>
<li><p>For the function <code>AddUserToGroup(string, string)</code>, it’s unclear whether the group name is provided as the first or the second argument.</p></li>
<li><p>What is the order of height and width in the <code>Rectangle (3.14, 5.67)</code> constructor call?</p></li>
<li><p>Does <code>Circle(double)</code> expect a radius or diameter?</p></li>
</ul>
<p>Documentation can correct for ambiguity, but developers are still bound to make mistakes. Unit tests can catch most of these errors if we’ve done our due diligence, but some errors may surface only at runtime.</p>
<p>When using strong types, you can catch these mistakes at compilation time. To return to our earlier example, the required calls would look like the following:</p>
<ul>
<li><p><code>Add(User("alice"), Group("root-users"))</code></p></li>
<li><p><code>Rectangle(Width(3.14), Height(5.67))</code></p></li>
<li><p><code>Circle(Radius(1.23))</code></p></li>
</ul>
<p>where <code>User</code>, <code>Group</code>, <code>Width</code>, <code>Height</code>, and <code>Radius</code> are strong type wrappers around string or double primitives. This approach is less error-prone and makes the code more self-documenting—in this context, in the first example it’s sufficient to call the function <code>Add</code>.</p>
<p class="pagebreak-before"><a contenteditable="false" data-primary="implicit type conversions" data-type="indexterm" id="ch12.html_ix37">&nbsp;</a><a contenteditable="false" data-primary="type conversions, implicit" data-type="indexterm" id="ch12.html_ix38">&nbsp;</a>In the second situation, implicit type conversions may lead to the following:</p>
<ul>
<li><p>Truncation when converting from larger to smaller integer types</p></li>
<li><p>Precision loss when converting from larger to smaller floating-point types</p></li>
<li><p>Unexpected object creation</p></li>
</ul>
<p>In some cases, a compiler will report the first two issues (for example, when using the <code>{}</code> direct initialization syntax in C++), but many instances will likely be overlooked. Using strong types protects your code from errors of this type that a compiler doesn’t capture.</p>
<p>Now let’s consider the case of the difficult-to-understand type hierarchy:</p>
<pre data-type="programlisting"><strong><span>class</span> <span>Bar</span></strong> <span>{</span><span>
 </span><strong><span>public</span></strong><span>:</span><span>
 </span> <span>Bar</span><span>(</span><strong><span>bool</span></strong> <span>is_safe</span><span>)</span> <span>{...}</span><span>
</span><span>};</span><span>

</span><strong><span>void</span> <span>Foo</span></strong><span>(</span><strong><span>const</span></strong> <span>Bar</span><span>&amp;</span> <span>bar</span><span>)</span> <span>{...}</span><span>

</span><span>Foo</span><span>(</span><span>false</span><span>);</span> <span/> <em>// Likely OK, but is the developer aware a Bar object was created?</em><span>
</span><span>Foo</span><span>(</span><span>5</span><span>);</span> <span>    </span> <em>// Will create Bar(is_safe := true), but likely by accident.</em><span>
</span><span>Foo</span><span>(</span><span>NULL</span><span>);</span> <span> </span> <em>// Will create Bar(is_safe := false), again likely by accident.</em></pre>

<p>The three calls here will compile and execute, but will the outcome of the operation match developers’ expectations? By default, a C++ compiler attempts to implicitly cast (<em>coerce</em>) parameters to match function argument types. In this case, the compiler will attempt to match the type <code>Bar</code>, which conveniently has a single-value constructor taking a parameter of type <code>bool</code>. Most C++ types implicitly cast to <code>bool</code>.</p>
<p><a contenteditable="false" data-primary="casting, implicit" data-type="indexterm" id="ch12.html_ix39">&nbsp;</a><a contenteditable="false" data-primary="implicit casting" data-type="indexterm" id="ch12.html_ix40">&nbsp;</a>Implicit casting in constructors is sometimes intended (for example, when converting floating-point values to the <code>std::complex</code> class), but can be dangerous in most situations. To prevent dangerous outcomes, at a minimum, make single-value constructors <em>explicit</em>—for example, <code>explicit Bar(bool is_safe)</code>. Note that the last call will result in a compilation error when using <code>nullptr</code> rather than <code>NULL</code> because there is no implicit conversion to <code>bool</code>.</p>
<p>Finally, unit confusion is an endless source of mistakes. These mistakes might be characterized as follows:</p>
<dl>
<dt>Harmless</dt>
<dd>For example, code that sets a timer for 30 seconds instead of 30 minutes because the programmer didn’t know what units <code>Timer(30)</code> uses.</dd>
<dt>Dangerous</dt>
<dd>For example, AirCanada’s <a href="https://en.wikipedia.org/wiki/Gimli_Glider">“Gimli Glider” airplane</a> had to make an emergency landing after ground crew calculated the necessary fuel in pounds instead of kilograms, leaving it with only half the required fuel.</dd>
<dt>Expensive</dt>
<dd>For example, scientists <a href="http://edition.cnn.com/TECH/space/9909/30/mars.metric.02/">lost the $125 million Mars Climate Orbiter</a> because two separate engineering teams used different units of measurement (imperial versus metric).</dd>
</dl>
<p>As before, strong types are a solution to this issue: they can encapsulate the unit, and represent only abstract concepts such as timestamp, duration, or weight. Such types typically implement the following:</p>
<dl>
<dt>Sensible operations</dt>
<dd>For example, adding two timestamps is not normally a useful operation, but subtracting them returns a duration that can be useful for many use cases. Adding two durations or weights is similarly useful.</dd>
<dt>Unit conversions</dt>
<dd>For example, T<code>imestamp::ToUnix, Duration::ToHours, Weight::ToKilograms</code>.</dd>
</dl>
<p>Some languages provide such abstractions natively: examples include the <a href="https://golang.org/pkg/time"><code>time</code> package</a> in Go and the <a href="http://www.wg21.link/p0355"><code>chrono</code> library</a> in the upcoming C++20 standard. Other languages might require a dedicated implementation.</p>
<p>The <a href="https://www.fluentcpp.com/2016/12/08/strong-types-for-strong-interfaces/">Fluent C++ blog</a> has more discussion on applications of strong types and example implementations in C++.<a contenteditable="false" data-primary="" id="ch12.html14-eot" data-startref="ch12.html14" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="" id="ch12.html13-eot" data-startref="ch12.html13" data-type="indexterm">&nbsp;</a></p>
</section>
<section data-type="sect2" id="sanitize_your_code">
<h2>Sanitize Your Code</h2>
<p><a contenteditable="false" data-primary="sanitizing code" data-type="indexterm" id="ch12.html_ix41">&nbsp;</a><a contenteditable="false" data-primary="writing code" data-secondary="sanitizing code" data-type="indexterm" id="ch12.html_ix42">&nbsp;</a>It’s very useful to automatically validate that your code is not experiencing any typical memory management or concurrency pitfalls. You can run these checks as a presubmit action for each change list or as part of a continuous build and test automation harness. The list of pitfalls to check is language-dependent. This section presents some solutions for C++ and Go.</p>
<section data-type="sect3" id="cplusplus_valgrind_or_google_sanitizers">
<h3>C++: Valgrind or Google Sanitizers</h3>
<p><a contenteditable="false" data-primary="C++" data-secondary="sanitizing code" data-type="indexterm" id="ch12.html_ix43">&nbsp;</a>C++ allows for low-level memory management. As we mentioned earlier, memory management errors are a leading cause of security issues, and can result in the following failure scenarios:</p>
<ul>
<li><p>Reading unallocated memory (before <code>new</code> or after <code>delete</code>)</p></li>
<li><p>Reading outside of the allocated memory (buffer overflow attack scenario)</p></li>
<li><p>Reading uninitialized memory</p></li>
<li><p>Memory leaks when a system loses the address of allocated memory or doesn’t deallocate unused memory early</p></li>
</ul>
<p><a contenteditable="false" data-primary="Valgrind" data-type="indexterm" id="ch12.html_ix44">&nbsp;</a><a href="http://www.valgrind.org">Valgrind</a> is a popular framework that allows developers to catch those sorts of errors, even if unit tests don’t catch them. Valgrind has the benefit of providing a virtual machine that interprets a user’s binary, so users don’t need to recompile their code to use it. The Valgrind tool <a href="http://www.valgrind.org/docs/manual/hg-manual.html">Helgrind</a> can additionally detect common synchronization errors such as these:</p>
<ul>
<li><p>Misuses of the POSIX pthreads API (e.g., unlocking a not-locked mutex, or a mutex held by another thread)</p></li>
<li><p>Potential deadlocks arising from lock ordering problems</p></li>
<li><p>Data races caused by accessing memory without adequate locking or synchronization</p></li>
</ul>
<p><a contenteditable="false" data-primary="Google Sanitizers" data-type="indexterm" id="ch12.html_ix45">&nbsp;</a>Alternatively, the <a href="https://github.com/google/sanitizers/wiki">Google Sanitizers suite</a> offers various components that can detect all the same issues that Valgrind’s Callgrind (a cache and branch prediction profiler) can detect:</p>
<ul>
<li><p>AddressSanitizer (ASan) detects memory errors (buffer overflows, use after free, incorrect initialization order).</p></li>
<li><p>LeakSanitizer (LSan) detects memory leaks.</p></li>
<li><p>MemorySanitizer (MSan) detects when a system is reading uninitialized <span class="keep-together">memory</span>.</p></li>
<li><p>ThreadSanitizer (TSan) detects data races and deadlocks.</p></li>
<li><p>UndefinedBehaviorSanitizer (UBSan) detects situations that have undefined behavior (using misaligned pointers; signed integer overflow; converting to, from, or between floating-point types that will overflow the destination).</p></li>
</ul>
<p>The main advantage of the Google Sanitizers suite is speed: it’s <a href="https://github.com/google/sanitizers/wiki/AddressSanitizerComparisonOfMemoryTools">up to 10 times faster</a> than Valgrind. Popular IDEs like <a href="https://www.jetbrains.com/help/clion/google-sanitizers.html">CLion</a> also provide first-class integration with Google Sanitizers. The next chapter provides more details on sanitizers and other dynamic program analysis tools.</p>
</section>
<section data-type="sect3" id="go_race_detector">
<h3>Go: Race Detector</h3>
<p><a contenteditable="false" data-primary="Go Race Detector" data-type="indexterm" id="ch12.html_ix46">&nbsp;</a>While Go is designed to disallow memory corruption issues typical to C++, it may still suffer from data race conditions. <a href="https://golang.org/doc/articles/race_detector.html">Go Race Detector</a> can detect these conditions.<a contenteditable="false" data-primary="" id="ch12.html11-eot" data-startref="ch12.html11" data-type="indexterm">&nbsp;</a></p>
</section>
</section>
</section>
<section data-type="sect1" id="conclusion-id00011">
<h1>Conclusion</h1>
<p>This chapter presented several principles that guide developers toward designing and implementing more secure and reliable code. In particular, we recommend using frameworks as a powerful strategy, as they reuse proven building blocks for sensitive areas of code prone to reliability and security issues: authentication, authorization, logging, rate limiting, and communication in distributed systems. Frameworks also tend to improve developer productivity—both for the people writing the framework and the people using the framework—and make reasoning about the code much easier. Additional strategies for writing secure and reliable code include aiming for simplicity, choosing the right tools, using strong rather than primitive types, and continuously sanitizing the codebase.</p>
<p>Investing extra effort in improving security and reliability while writing software pays off in the long run, and reduces the effort you have to spend reviewing your application or fixing issues after your application is deployed.<a contenteditable="false" data-primary="" id="ch12.html0-eot" data-startref="ch12.html0" data-type="indexterm">&nbsp;</a></p>
</section>
</section>
</body>
</html>
<div data-type="footnotes">
<p data-type="footnote" id="ch12fn1"><sup><a href="#ch12fn1-marker">1</a></sup>See <a class="orm:hideurl" href="https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/">Chapter 22 of the SRE book</a> for more on cascading failures.</p>
<p data-type="footnote" id="ch12fn2"><sup><a href="#ch12fn2-marker">2</a></sup>Also described in <a class="orm:hideurl" href="https://landing.google.com/sre/sre-book/chapters/addressing-cascading-failures/">Chapter 22 of the SRE book</a>.</p>
<p data-type="footnote" id="ch12fn3"><sup><a href="#ch12fn3-marker">3</a></sup>See the <a href="https://github.com/OWASP/CheatSheetSeries/blob/master/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.md">XXE Prevention Cheat Sheet</a> for more information.</p>
<p data-type="footnote" id="ch12fn4"><sup><a href="#ch12fn4-marker">4</a></sup>This system is described in more detail in Kern, Christoph. 2014. “Securing the Tangled Web.” <em>Communications of the ACM</em> 57(9): 38–47. <a href="https://ai.google/research/pubs/pub42934"><em class="hyperlink">https://ai.google/research/pubs/pub42934</em></a>.</p>
<p data-type="footnote" id="ch12fn5"><sup><a href="#ch12fn5-marker">5</a></sup>See Bessey, Al et al. 2010. “A Few Billion Lines of Code Later: Using Static Analysis to Find Bugs in the Real World.” <em>Communications of the ACM</em> 53(2): 66–75. doi:10.1145/1646353.1646374.</p>
<p data-type="footnote" id="ch12fn6"><sup><a href="#ch12fn6-marker">6</a></sup>Potvin, Rachel, and Josh Levenberg. 2016. “Why Google Stores Billions of Lines of Code in a Single Repository.” <em>Communications of the ACM</em> 59(7): 78–87. doi:10.1145/2854146.</p>
<p data-type="footnote" id="ch12fn7"><sup><a href="#ch12fn7-marker">7</a></sup>See, e.g., Ousterhout, John. 2018. <em>A Philosophy of Software Design</em>. Palo Alto, CA: Yaknyam Press.</p>
<p data-type="footnote" id="ch12fn8"><sup><a href="#ch12fn8-marker">8</a></sup>Source: Karpilovsky, Elliott. 2017. “Code Health: Reduce Nesting, Reduce Complexity.” <a href="https://testing.googleblog.com/2017/06/code-health-reduce-nesting-reduce.html"><em class="hyperlink">https://testing.googleblog.com/2017/06/code-health-reduce-nesting-reduce.html</em></a>.</p>
<p data-type="footnote" id="ch12fn9"><sup><a href="#ch12fn9-marker">9</a></sup>Source: Eaddy, Marc. 2017. “Code Health: Eliminate YAGNI Smells.” <a href="https://testing.googleblog.com/2017/08/code-health-eliminate-yagni-smells.html"><em class="hyperlink">https://testing.googleblog.com/2017/08/code-health-eliminate-yagni-smells.html</em></a>.</p>
<p data-type="footnote" id="ch12fn10"><sup><a href="#ch12fn10-marker">10</a></sup>A wide selection of code coverage tools are available. For an overview, see the list on <a href="https://stackify.com/code-coverage-tools/">Stackify</a>.</p>
<p data-type="footnote" id="ch12fn11"><sup><a href="#ch12fn11-marker">11</a></sup>Fowler, Martin. 2019. <em>Refactoring: Improving the Design of Existing Code</em>. Boston, MA: Addison-Wesley.</p>
<p data-type="footnote" id="ch12fn12"><sup><a href="#ch12fn12-marker">12</a></sup>Wright, Hyrum et al. 2013. “Large-Scale Automated Refactoring Using Clang.” <em>Proceedings of the 29<sup>th</sup> International Conference on Software Maintenance</em>: 548–551. doi:10.1109/ICSM.2013.93. </p>
<p data-type="footnote" id="ch12fn13"><sup><a href="#ch12fn13-marker">13</a></sup>Wasserman, Louis. 2013. “Scalable, Example-Based Refactorings with Refaster.” <em>Proceedings of the 2013 ACM Workshop on Refactoring Tools</em>: 25–28 doi:10.1145/2541348.2541355.</p>
<p data-type="footnote" id="ch12fn14"><sup><a href="#ch12fn14-marker">14</a></sup>Miller, Matt. 2019. “Trends, Challenges, and Strategic Shifts in the Software Vulnerability Mitigation Landscape.” BlueHat IL. <a href="https://goo.gl/vKM7uQ"><em class="hyperlink">https://goo.gl/vKM7uQ</em></a>.  </p>
<p data-type="footnote" id="ch12fn15"><sup><a href="#ch12fn15-marker">15</a></sup>Kralevich, Nick. 2016. “The Art of Defense: How Vulnerabilities Help Shape Security Features and Mitigations in Android.” BlackHat. <a href="https://www.blackhat.com/docs/us-16/materials/us-16-Kralevich-The-Art-Of-Defense-How-Vulnerabilities-Help-Shape-Security-Features-And-Mitigations-In-Android.pdf"><em class="hyperlink">https://www.blackhat.com/docs/us-16/materials/us-16-Kralevich-The-Art-Of-Defense-How-Vulnerabilities-Help-Shape-Security-Features-And-Mitigations-In-Android.pdf</em></a>.  </p>
<p data-type="footnote" id="ch12fn16"><sup><a href="#ch12fn16-marker">16</a></sup>Liskov, Barbara, and Stephen Zilles. 1974. “Programming with Abstract Data Types.” <em>Proceedings of the ACM SIGPLAN Symposium on Very High Level Languages</em>: 50–59. doi:10.1145/800233.807045  </p>
<p data-type="footnote" id="ch12fn17"><sup><a href="#ch12fn17-marker">17</a></sup>For many more surprises in JavaScript and Ruby, see <a href="https://www.destroyallsoftware.com/talks/wat">Gary Bernhardt’s lightning talk from CodeMash 2012</a>.   </p>
<p data-type="footnote" id="ch12fn18"><sup><a href="#ch12fn18-marker">18</a></sup>See Eaddy, Mark. 2017. “Code Health: Obsessed with Primitives?” <a href="https://testing.googleblog.com/2017/11/obsessed-with-primitives.html"><em class="hyperlink">https://testing.googleblog.com/2017/11/obsessed-with-primitives.html</em></a>.</p>
</div>
