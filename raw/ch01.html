<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Building Secure and Reliable Systems</title>
  <link rel="stylesheet" type="text/css" href="theme/html/html.css">
</head>
<body data-type="book">
<section data-type="chapter" id="the_intersection_of_security_and_reliab" xmlns="http://www.w3.org/1999/xhtml">
<h1>The Intersection of Security and Reliability</h1>

<p class="byline">By Adam Stubblefield, Massimiliano Poletto, <span class="keep-together">and Piotr Lewandowski</span></p>

<p class="byline cont">with David Huska and Betsy Beyer‎</p>

<section data-type="sect1" id="on_passwords_and_power_drills">
<h1>On Passwords and Power Drills</h1>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-type="indexterm" id="ch01.html0">&nbsp;</a>On <a contenteditable="false" data-primary="Google" data-secondary="password manager incident" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="Google password manager incident" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="passwords" data-type="indexterm">&nbsp;</a>September 27, 2012, an innocent Google-wide announcement caused a series of cascading failures in an internal service. Ultimately, recovering from these failures required a power drill.</p>

<p>Google has an internal password manager that allows employees to store and share secrets for third-party services that don’t support better authentication mechanisms. One such secret is the password to the guest WiFi system on the large fleet of buses that connect Google’s San Francisco Bay Area campuses.</p>

<p>On that day in September, the corporate transportation team emailed an announcement to thousands of employees that the WiFi password had changed. The resulting spike in traffic was far larger than the password management system—which had been developed years earlier for a small audience of system administrators—could handle.</p>

<p>The load caused the primary replica of the password manager to become unresponsive, so the load balancer diverted traffic to the secondary replica, which promptly failed in the same way. At this point, the system paged the on-call engineer. The engineer had no experience responding to failures of the service: the password manager was supported on a best-effort basis, and had never suffered an outage in its five years of existence. The engineer attempted to restart the service, but did not know that a restart required a hardware security module (HSM) smart card.</p>

<p>These smart cards were stored in multiple safes in different Google offices across the globe, but not in New York City, where the on-call engineer was located. When the service failed to restart, the engineer contacted a colleague in Australia to retrieve a smart card. To their great dismay, the engineer in Australia could not open the safe because the combination was stored in the now-offline password manager. Fortunately, another colleague in California had memorized the combination to the on-site safe and was able to retrieve a smart card. However, even after the engineer in California inserted the card into a reader, the service still failed to restart with the cryptic error, “The password could not load any of the cards protecting this key.”</p>

<p>At this point, the engineers in Australia decided that a brute-force approach to their safe problem was warranted and applied a power drill to the task. An hour later, the safe was open—but even the newly retrieved cards triggered the same error message.</p>

<p>It took an additional hour for the team to realize that the green light on the smart card reader did not, in fact, indicate that the card had been inserted correctly. When the engineers flipped the card over, the service restarted and the outage ended.</p>

<p>Reliability and security are both crucial components of a truly trustworthy system, but building systems that are both reliable and secure is difficult. While the requirements for reliability and security share many common properties, they also require different design considerations. It is easy to miss the subtle interplay between reliability and security that can cause unexpected outcomes. The password manager’s failure was triggered by a reliability problem—poor load-balancing and load-shedding strategies—and its recovery was later complicated by multiple measures designed to increase the security of the system.</p>

<aside data-type="sidebar" id="the_intersection_of_security_and_privac">
<h5>The Intersection of Security and Privacy</h5>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="relationship between security and reliability" data-type="indexterm">&nbsp;</a>Security and privacy are closely related concepts. In order for a system to respect user privacy, it must be fundamentally secure and behave as intended in the presence of an adversary. Similarly, a perfectly secure system doesn’t meet the needs of many users if it doesn’t respect user privacy. While this book focuses on security, you can often apply the general approaches we describe to achieve privacy objectives, as well.</p>
</aside>
</section>

<section data-type="sect1" id="reliability_versus_security_design_cons">
<h1>Reliability Versus Security: Design Considerations</h1>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="design considerations" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="risk" data-secondary="reliability versus security design considerations" data-type="indexterm">&nbsp;</a>In designing for reliability and security, you must consider different risks. <a contenteditable="false" data-primary="reliability risks" data-type="indexterm">&nbsp;</a>The primary reliability risks are nonmalicious in nature—for example, a bad software update or a physical device failure. <a contenteditable="false" data-primary="security risks" data-type="indexterm">&nbsp;</a>Security risks, however, come from adversaries who are actively trying to exploit system vulnerabilities. When designing for reliability, you assume that some things will go wrong at some point. When designing for security, you must assume that an adversary could be trying to make things go wrong at any point.</p>

<p>As a result, different systems are designed to respond to failures in quite different ways. In the absence of an adversary, systems often fail <em>safe</em> (or <em>open</em>): for example, an electronic lock is designed to remain open in case of power failure, to allow safe exit through the door. Fail safe/open behavior can lead to obvious security vulnerabilities. To defend against an adversary who might exploit a power failure, you could design the door to fail <em>secure</em> and remain closed when not powered.</p>

<aside data-type="sidebar" id="reliability_and_security_tradeoff_redun">
<h5>Reliability and Security Tradeoff: Redundancy</h5>

<p><a contenteditable="false" data-primary="redundancy" data-secondary="reliability/security tradeoffs" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="tradeoffs, reliability/security" data-secondary="redundancy" data-type="indexterm">&nbsp;</a>In designing for reliability, you often need to add redundancy to systems. For instance, many electronic locks fail secure but accept a physical key during power failures. Similarly, fire escapes provide a redundant exit path for emergencies. <a contenteditable="false" data-primary="attack surface" data-secondary="redundancy and" data-type="indexterm">&nbsp;</a>While redundancy increases reliability, it also increases the attack surface. An adversary need only find a vulnerability in one path to be successful.</p>
</aside>

<aside data-type="sidebar" id="reliability_and_security_tradeoff_incid">
<h5>Reliability and Security Tradeoff: Incident Management</h5>

<p><a contenteditable="false" data-primary="crisis management" data-secondary="reliability/security tradeoffs" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="tradeoffs, reliability/security" data-secondary="incident management" data-type="indexterm">&nbsp;</a>The presence of an adversary can also affect methods of collaboration and the information that’s available to responders during an incident. Reliability incidents benefit from having responders with multiple perspectives who can help find and mitigate the root cause quickly. By contrast, you’ll often want to handle security incidents with the smallest number of people who can fix the problem effectively, so the adversary isn’t tipped off to the recovery effort. In the security case, you’ll share information on a <em>need-to-know</em> basis. <a contenteditable="false" data-primary="logging" data-secondary="logs as attack target" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="system logs, as attack target" data-type="indexterm">&nbsp;</a>Similarly, voluminous system logs may inform the response to an incident and reduce your time to recovery, but—depending on what is logged—those logs may be a valuable target for an attacker.</p>
</aside>
</section>

<section data-type="sect1" id="confidentialitycomma_integritycomma_ava">
<h1>Confidentiality, Integrity, Availability</h1>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="confidentiality, integrity, availability" data-type="indexterm" id="ch01.html1">&nbsp;</a>Both security and reliability are concerned with the confidentiality, integrity, and availability of systems, but they view these properties through different lenses. The key difference between the two viewpoints is the presence or lack of a malicious adversary. A reliable system must not breach confidentiality accidentally, like a buggy chat system that misdelivers, garbles, or loses messages might. Additionally, a secure system must prevent an active adversary from accessing, tampering with, or destroying confidential data. Let’s take a look at a few examples that demonstrate how a reliability problem can lead to a security issue.</p>

<div data-type="note">
<p><a contenteditable="false" data-primary="CIA (confidentiality, integrity, availability) triad" data-type="indexterm">&nbsp;</a>Confidentiality, integrity, and availability have traditionally been considered fundamental attributes of secure systems and are referred to as the <em>CIA triad</em>. While many other models extend the set of security attributes beyond these three, the CIA triad has remained popular over time. Despite the acronym, this concept is not related to the Central Intelligence Agency in any way.</p>
</div>

<section data-type="sect2" id="confidentiality">
<h2>Confidentiality</h2>

<p><a contenteditable="false" data-primary="confidentiality" data-secondary="reliability/security intersection" data-type="indexterm">&nbsp;</a>In the aviation industry, having a push-to-talk microphone <a href="https://www.faa.gov/air_traffic/publications/atpubs/aim_html/chap4_section_2.html">stuck in the transmit position</a> is a notable confidentiality problem. In several well-documented cases, a stuck mike has broadcast private conversations between pilots in the cockpit, which represents a breach of confidentiality. In this case, no malicious adversary is involved: a hardware reliability flaw causes the device to transmit when the pilot does not intend it to.</p>
</section>

<section data-type="sect2" id="integrity">
<h2>Integrity</h2>

<p><a contenteditable="false" data-primary="data integrity" data-type="indexterm">&nbsp;</a>Similarly, data integrity compromise need not involve an active adversary. In 2015, Google Site Reliability Engineers (SREs) noticed that the end-to-end cryptographic integrity checks on a few blocks of data were failing. Because some of the machines that processed the data later demonstrated evidence of uncorrectable memory errors, the SREs decided to write software that exhaustively computed the integrity check for every version of the data with a single-bit flip (a 0 changed to a 1, or vice versa). That way, they could see if one of the results matched the value of the original integrity check. All errors indeed turned out to be single-bit flips, and the SREs recovered all the data. Interestingly, this was an instance of a security technique coming to the rescue during a reliability incident. (Google’s storage systems also use noncryptographic end-to-end integrity checks, but other issues prevented SREs from detecting the bit flips.)</p>
</section>

<section data-type="sect2" id="availability">
<h2>Availability</h2>

<p>Finally, of course, availability is both a reliability and a security concern. An adversary might exploit a system’s weak spot to bring the system to a halt or impair its operation for authorized users. <a contenteditable="false" data-primary="distributed denial-of-service (DDoS) attacks" data-secondary="reliability/security intersection" data-type="indexterm">&nbsp;</a>Or they might control a large number of devices spread around the world to perform a classic distributed denial-of-service (DDoS) attack, instructing the many devices to flood a victim with traffic.</p>

<p><a contenteditable="false" data-primary="denial-of-service (DoS) attacks" data-secondary="reliability/security intersection" data-type="indexterm">&nbsp;</a>Denial-of-service (DoS) attacks are an interesting case because they straddle the areas of reliability and security. From a victim’s point of view, a malicious attack may be indistinguishable from a design flaw or a legitimate spike in traffic. For example, <a href="https://redd.it/9iivc5">a 2018 software update</a> caused some Google Home and <span class="keep-together">Chromecast</span> devices to generate large synchronized spikes in network traffic as the devices adjusted their clocks, resulting in unexpected load on Google’s central time service. Similarly, a major breaking news story or other event that prompts millions of people to issue near-identical queries can look very much like a traditional application-level DDoS attack. As shown in <a data-type="xref" href="#web_trafficcomma_measured_in_http_requ">Figure 1-1</a>, when a magnitude 4.5 earthquake hit the San Francisco Bay Area in the middle of the night in October 2019, Google infrastructure serving the area was hit with a flood of queries.<a contenteditable="false" data-primary="" data-startref="ch01.html1" data-type="indexterm">&nbsp;</a></p>

<figure id="web_trafficcomma_measured_in_http_requ">
<img alt="Figure 1-1: Web traffic, measured in HTTP requests per second, reaching Google infrastructure serving users in the San Francisco Bay Area when a magnitude 4.5 earthquake hit the region on October 14, 2019" src="images/bsrs_0101.png" />
<figcaption>Figure 1-1: Web traffic, measured in HTTP requests per second, reaching Google infrastructure serving users in the San Francisco Bay Area when a magnitude 4.5 earthquake hit the region on October 14, 2019</figcaption>
</figure>
</section>
</section>

<section data-type="sect1" id="reliability_and_security_commonalities">
<h1>Reliability and Security: Commonalities</h1>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="commonalities between reliability and security" data-type="indexterm" id="ch01.html2">&nbsp;</a>Reliability and security—unlike many other system characteristics—are emergent properties of a system’s design. Both are also difficult to bolt on after the fact, so you should ideally take both into account from the earliest design stages. They also require ongoing attention and testing throughout the entire system lifecycle, because it is easy for system changes to inadvertently affect them. In a complex system, reliability and security properties are often determined by the interaction of many components, and an innocuous-looking update to one component may end up affecting the reliability or security of the entire system in a way that may not be evident until it causes an incident. Let’s examine these and other commonalities in more detail.</p>

<section data-type="sect2" id="invisibility">
<h2>Invisibility</h2>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="invisibility" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="invisibility, of reliability and security" data-type="indexterm">&nbsp;</a>Reliability and security are mostly invisible when everything is going well. But one of the goals of reliability and security teams is to earn and keep the trust of customers and partners. <a contenteditable="false" data-primary="communication" data-secondary="foundation for trust" data-type="indexterm">&nbsp;</a>Good communication—not only in times of trouble, but also when things are going well—is a solid foundation for this trust. It is important that the information be—to the greatest degree possible—honest and concrete, and free of platitudes and jargon.</p>

<p><a contenteditable="false" data-primary="costs" data-secondary="reliability/security failures" data-type="indexterm">&nbsp;</a>Unfortunately, the inherent invisibility of reliability and security in the absence of emergencies means that they’re often seen as costs that you can reduce or defer without immediate consequences. However, the costs of reliability and security failures can be severe. <a contenteditable="false" data-primary="Verizon" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="Yahoo!" data-type="indexterm">&nbsp;</a>According to media reports, <a href="https://eu.usatoday.com/story/tech/news/2017/02/21/verizon-shaves-350-million-yahoo-price/98188452/">data breaches</a> may have led to a $350 million reduction in the price Verizon paid to acquire Yahoo!’s internet business in 2017. <a contenteditable="false" data-primary="Delta Airlines" data-type="indexterm">&nbsp;</a>In the same year, <a href="https://www.wired.com/2016/08/computer-outage-can-take-whole-airline/">a power failure</a> caused key computer systems to shut down at Delta Airlines and resulted in almost 700 flight cancellations and thousands of delays, reducing Delta’s flight throughput for the day by approximately 60%.</p>
</section>

<section data-type="sect2" id="assessment">
<h2>Assessment</h2>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="assessment" data-type="indexterm">&nbsp;</a>Because it’s not practical to achieve perfect reliability or security, you can use risk-based approaches to estimate the costs of negative events, as well as the up-front and opportunity costs of preventing these events. However, you should measure the probability of negative events differently for reliability and security. You can reason about the reliability of a composition of systems and plan engineering work according to desired error budgets,<sup><a data-type="noteref" id="ch01fn2-marker" href="#ch01fn2">1</a></sup> at least in part because you can assume independence of failures across the individual components. The security of such a composition is more difficult to assess. Analyzing a system’s design and implementation can afford some level of assurance. <a contenteditable="false" data-primary="adversarial testing" data-type="indexterm">&nbsp;</a>Adversarial testing—simulated attacks typically performed from the perspective of a defined adversary—can also be used to evaluate a system’s resistance to particular kinds of attacks, the effectiveness of attack detection mechanisms, and the potential consequences of attacks.</p>
</section>

<section data-type="sect2" id="simplicity">
<h2>Simplicity</h2>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="simplicity" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="simplicity" data-type="indexterm">&nbsp;</a>Keeping system design as simple as possible is one of the best ways to improve your ability to assess both the reliability and the security of a system. A simpler design reduces the attack surface, decreases the potential for unanticipated system interactions, and makes it easier for humans to comprehend and reason about the system. Understandability is especially valuable during emergencies, when it can help <span class="keep-together">responders</span> mitigate symptoms quickly and reduce mean time to repair (MTTR). <a data-type="xref" href="#design_for_understandability">Chapter 6</a> elaborates on this topic and discusses strategies such as minimizing attack surfaces and isolating responsibility for security invariants into small, simple subsystems that can be reasoned about independently.</p>
</section>

<section data-type="sect2" class="pagebreak-before" id="evolution">
<h2 class="less_space">Evolution</h2>

<p><a contenteditable="false" data-primary="complexity" data-secondary="evolution and" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="evolution of systems" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="evolution" data-type="indexterm">&nbsp;</a>No matter how simple and elegant the initial design, systems rarely remain unchanged over time. New feature requirements, changes in scale, and evolution of the underlying infrastructure all tend to introduce complexity. On the security side, the need to keep up with evolving attacks and new adversaries can also increase system complexity. Additionally, pressure to meet market demands can lead system developers and maintainers to cut corners and accumulate technical debt. <a data-type="xref" href="#design_for_a_changing_landscape">Chapter 7</a> addresses some of these challenges.</p>

<p><a contenteditable="false" data-primary="complexity" data-secondary="in evolving systems" data-type="indexterm">&nbsp;</a>Complexity often accumulates inadvertently, but this can lead to tipping-point situations where a small and apparently innocuous change has major consequences for a system’s reliability or security. <a contenteditable="false" data-primary="OpenSSL library" data-type="indexterm">&nbsp;</a>A bug that was introduced in 2006 and discovered almost two years later in the Debian GNU/Linux version of the OpenSSL library provides <a href="https://www.debian.org/security/2008/dsa-1571">one notorious example</a> of a major failure caused by a small change. <a contenteditable="false" data-primary="Valgrind" data-type="indexterm">&nbsp;</a>An open source developer noticed that Valgrind, a standard tool for debugging memory problems, was reporting warnings about memory used prior to initialization. To eliminate the warnings, the developer removed two lines of code. Unfortunately, this caused OpenSSL’s pseudo-random number generator to only be seeded with a process ID, which on Debian at the time defaulted to a number between 1 and 32,768. Brute force could then easily break cryptographic keys.</p>

<p>Google has not been immune to failures triggered by seemingly innocuous changes. <a contenteditable="false" data-primary="YouTube" data-type="indexterm">&nbsp;</a>For example, in October 2018, <a href="https://www.theverge.com/2018/10/16/17987280/youtube-down-outage">YouTube was down</a> globally for more than an hour because of a small change in a generic logging library. A change intended to improve the granularity of event logging looked innocent to both its author and the designated code reviewer, and it passed all tests. However, the developers didn’t fully realize the impact of the change at YouTube scale: under production load, the change quickly caused YouTube servers to run out of memory and crash. As the failures shifted user traffic toward other, still healthy servers, cascading failures brought the entire service to a halt.</p>
</section>

<section data-type="sect2" id="resilience">
<h2>Resilience</h2>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="resilience" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="resilience, designing for" data-secondary="intersection of security and reliability" data-type="indexterm">&nbsp;</a>Of course, a memory utilization problem should not have caused a global service outage. Systems should be designed to be resilient under adverse or unexpected circumstances. From the reliability perspective, such circumstances are often caused by unexpectedly high load or component failures. Load is a function of the volume and the average cost of requests to the system, so you can achieve resilience by shedding some of the incoming load (processing less) or reducing the processing cost for each request (processing more cheaply). To address component failures, system design should incorporate redundancy and distinct failure domains so that you can limit the impact of failures by rerouting requests. <a data-type="xref" href="#design_for_resilience">Chapter 8</a> discusses these topics further, and <a data-type="xref" href="#mitigating_denial_of_service_attacks">Chapter 10</a> goes into depth on DoS mitigations in particular.</p>

<p>However resilient a system’s individual components might be, once it becomes sufficiently complex, you cannot easily demonstrate that the entire system is immune to compromise. <a contenteditable="false" data-primary="defense in depth" data-secondary="resilience and" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="distinct failure domains" data-secondary="resilience and" data-type="indexterm">&nbsp;</a>You can address this problem in part using defense in depth and distinct failure domains. <em>Defense in depth</em> is the application of multiple, sometimes redundant, defense mechanisms. <em>Distinct failure domains</em> limit the “blast radius” of a failure and therefore also increase reliability. A good system design limits an adversary’s ability to exploit a compromised host or stolen credentials in order to move laterally or to escalate privilege and affect other parts of the system.</p>

<p>You can implement distinct failure domains by compartmentalizing permissions or restricting the scope of credentials. For example, Google’s internal infrastructure supports credentials that are explicitly scoped to a geographic region. These types of features can limit the ability of an attacker who compromises a server in one region to move laterally to servers in other regions.</p>

<p><a contenteditable="false" data-primary="encryption" data-secondary="defense in depth and" data-type="indexterm">&nbsp;</a>Employing independent encryption layers for sensitive data is another common mechanism for defense in depth. For example, even though disks provide device-level encryption, it’s often a good idea to also encrypt the data at the application layer. This way, even a flawed implementation of an encryption algorithm in a drive controller won’t be sufficient to compromise the confidentiality of protected data if an attacker gains physical access to a storage device.</p>

<p><a contenteditable="false" data-primary="insider risk" data-secondary="resilience and" data-type="indexterm">&nbsp;</a>While the examples cited so far hinge on external attackers, you must also consider potential threats from malicious insiders. Although an insider may know more about potential abuse vectors than an external attacker who steals an employee’s credentials for the first time, the two cases often don't differ much in practice. The <em>principle of least privilege</em> can mitigate insider threats. It dictates that a user should have the minimal set of privileges required to perform their job at a given time. For example, mechanisms like Unix’s <code>sudo</code> support fine-grained policies that specify which users can run which commands as which role.</p>

<p><a contenteditable="false" data-primary="multi-party authorization (MPA)" data-secondary="resilience and" data-type="indexterm">&nbsp;</a>At Google, we also use multi-party authorization to ensure that sensitive operations are reviewed and approved by specific sets of employees. This multi-party mechanism both protects against malicious insiders and reduces the risk of innocent human error, a common cause of reliability failures. Least privilege and multi-party authorization are not new ideas—they have been employed in many noncomputing scenarios, from nuclear missile silos to bank vaults. <a data-type="xref" href="#design_for_least_privilege">Chapter 5</a> discusses these concepts in depth.</p>
</section>

<section data-type="sect2" id="from_design_to_production">
<h2>From Design to Production</h2>

<p><a contenteditable="false" data-primary="deployment (generally)" data-secondary="system" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="deployment of design" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="production" data-secondary="intersection of security and reliability" data-type="indexterm">&nbsp;</a>Security and reliability considerations should be kept in mind when translating even a solid design into a fully deployed production system. Starting with the development of the code, opportunities exist to spot potential security and reliability issues through code reviews, and even to prevent entire classes of problems by using common frameworks and libraries. <a data-type="xref" href="#writing_code">Chapter 12</a> discusses some of these techniques.</p>

<p>Before deploying a system, you can use testing to ensure that it functions correctly both in normal scenarios and in the edge cases that typically impact reliability and security. Whether you use load testing to understand the behavior of a system under a flood of queries, fuzzing to explore the behavior on potentially unexpected inputs, or specialized tests to ensure that cryptographic libraries aren’t leaking information, testing plays a critical role in gaining assurance that the system you’ve actually built matches your design intentions. <a data-type="xref" href="#onethree_testing_code">Chapter 13</a> covers these approaches in depth.</p>

<p>Finally, some approaches to actually deploying code (see <a data-type="xref" href="#onefour_deploying_code">Chapter 14</a>) can limit security and reliability risk. For example, canaries and slow rollouts can prevent you from breaking the system for all users simultaneously. Similarly, a deployment system that accepts only code that’s been properly reviewed can help to mitigate the risk of an insider pushing a malicious binary to production.</p>
</section>

<section data-type="sect2" id="investigating_systems_and_logging">
<h2>Investigating Systems and Logging</h2>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="logging" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="investigating systems" data-secondary="intersection of security and reliability" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="logging" data-secondary="intersection of security and reliability" data-type="indexterm">&nbsp;</a>So far we have focused on design principles and implementation approaches to prevent both reliability and security failures. Unfortunately, it is usually impractical or too expensive to attain perfect reliability or security. You must assume that preventive mechanisms will fail, and craft a plan to detect and recover from failures.</p>

<p>As we discuss in <a data-type="xref" href="#onefive_investigating_systems">Chapter 15</a>, good logging is the foundation of detection and failure preparedness. In general, the more complete and detailed your logs, the better—but this guideline has some caveats. At sufficient scale, log volume poses a significant cost, and analyzing logs effectively can become difficult. The YouTube example from earlier in this chapter illustrates that logging can also introduce reliability problems. Security logs pose an additional challenge: logs typically should not contain sensitive information, such as authentication credentials or personally identifiable information (PII), lest the logs themselves become attractive targets for adversaries.</p>
</section>

<section data-type="sect2" id="crisis_response">
<h2>Crisis Response</h2>

<p><a contenteditable="false" data-primary="crisis management" data-secondary="intersection of security and reliability" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="crisis response" data-type="indexterm">&nbsp;</a>During an emergency, teams must work together quickly and smoothly because problems can have immediate consequences. In the worst case, an incident can destroy a business in minutes. <a contenteditable="false" data-primary="Code Spaces" data-type="indexterm">&nbsp;</a>For example, in 2014 an attacker put the code-hosting service Code Spaces out of business in a matter of hours by taking over the service’s administrative tools and deleting all of its data, <a href="https://threatpost.com/hacker-puts-hosting-service-code-spaces-out-of-business/106761/">including all backups</a>. Well-rehearsed collaboration and good incident management are critical for timely responses in these situations.</p>

<p>Organizing crisis response is challenging, so it’s best to have a plan in place before an emergency occurs. By the time you discover an incident, the clock may have been ticking for some time. In any case, responders are operating under stress and time pressure, and (at least initially) with limited situational awareness. If an organization is large and the incident requires 24/7 response capabilities or collaboration across time zones, the need to maintain state across teams and to hand off incident management at the boundaries of work shifts further complicates operations. Security incidents also typically entail tension between the impulse to involve all essential parties versus the need—often driven by legal or regulatory requirements—to restrict information sharing on a need-to-know basis. Moreover, the initial security incident may be just the tip of the iceberg. The investigation might grow beyond company boundaries or involve law enforcement agencies.</p>

<p>During a crisis, it is essential to have a clear chain of command and a solid set of checklists, playbooks, and protocols. As discussed in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="#onesix_disaster_planning">Chapter 16</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#oneseven_crisis_management">Chapter 17</a>, <a contenteditable="false" data-primary="Incident Management at Google (IMAG)" data-secondary="crisis response" data-type="indexterm">&nbsp;</a>Google has <a href="https://landing.google.com/sre/workbook/chapters/incident-response/">codified crisis response</a> into a program called Incident Management at Google (IMAG), which establishes a standard, consistent way to handle all types of incidents, from system outages to natural disasters, and organize an effective response. <a contenteditable="false" data-primary="Disaster Recovery Testing (DiRT) program" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="Incident Command System" data-type="indexterm">&nbsp;</a>IMAG was modeled on the US government’s <a href="https://training.fema.gov/emiweb/is/icsresource/trainingmaterials.htm">Incident Command System (ICS)</a>, a standardized approach to the command, control, and coordination of emergency response among responders from multiple government agencies.</p>

<p>When not faced with the pressure of an ongoing incident, responders typically negotiate long intervals with little activity. During these times, teams need to keep individuals’ skills and motivation sharp and improve processes and infrastructure in preparation for the next emergency. Google’s <a href="https://queue.acm.org/detail.cfm?id=2371516">Disaster Recovery Testing program (DiRT)</a> regularly simulates various internal system failures and forces teams to cope with these types of scenarios. Frequent offensive security exercises test our defenses and help identify new vulnerabilities. Google employs IMAG even for small incidents, which further prompts us to regularly exercise emergency tools and processes.</p>
</section>

<section data-type="sect2" id="recovery">
<h2>Recovery</h2>

<p><a contenteditable="false" data-primary="intersection of security and reliability" data-secondary="recovery" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="recovery" data-secondary="intersection of security and reliability" data-type="indexterm">&nbsp;</a>Recovering from a security failure often requires patching systems to fix a vulnerability. Intuitively, you want that process to happen as quickly as possible, using mechanisms that are exercised regularly and are therefore decently reliable. However, the capability to push changes quickly is a double-edged sword: while this capability can help close vulnerabilities quickly, it can also introduce bugs or performance issues that cause a lot of damage. The pressure to push patches quickly is greater if the vulnerability is widely known or severe. The choice of whether to push fixes slowly—and therefore to have more assurance that there are no inadvertent side effects, but risk that the vulnerability will be exploited—or to do so quickly ultimately comes down to a risk assessment and a business decision. For example, it may be acceptable to lose some performance or increase resource usage to fix a severe vulnerability.</p>

<p>Choices like this underscore the need for reliable recovery mechanisms that allow us to roll out necessary changes and updates quickly without compromising reliability, and that also catch potential problems before they cause a widespread outage. For example, a robust fleet recovery system needs to have a reliable representation of every machine’s current and desired state, and also needs to provide backstops to ensure that state is never rolled back to an obsolete or unsafe version. <a data-type="xref" href="#design_for_recovery">Chapter 9</a> covers this and many other approaches, and <a data-type="xref" href="#oneeight_recovery_and_aftermath">Chapter 18</a> discusses how to actually recover systems once an event has occurred.<a contenteditable="false" data-primary="" data-startref="ch01.html2" data-type="indexterm">&nbsp;</a></p>
</section>
</section>

<section data-type="sect1" id="conclusion">
<h1>Conclusion</h1>

<p>Security and reliability have a lot in common—both are inherent properties of all information systems that are tempting to initially sacrifice in the name of velocity, but costly to fix after the fact. This book aims to help you address inevitable challenges related to security and reliability early on, as your systems evolve and grow. Alongside engineering efforts, each organization has to understand the roles and responsibilities (see <a data-type="xref" href="#twozero_understanding_roles_and_respons">Chapter 20</a>) that contribute to building a culture of security and reliability (<a data-type="xref" href="#twoone_building_a_culture_of_security_a">Chapter 21</a>) in order to persist sustainable practices. By sharing our experiences and lessons learned, we hope to enable you to avoid paying a bigger price further down the road by adopting some of the principles described here sufficiently early in the system lifecycle.</p>

<p>We wrote this book with a broad audience in mind, with the goal that you will find it relevant regardless of the stage or scope of your project. While reading it, keep the risk profile of your project in mind—operating a stock exchange or a communication platform for dissidents has a drastically different risk profile than running a website for an animal sanctuary. The next chapter discusses the classes of adversaries and their possible motivations in detail.<a contenteditable="false" data-primary="" data-startref="ch01.html0" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="ACLs" data-see="access control lists" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="App Engine" data-see="Google App Engine" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="attackers" data-see="adversaries, understanding" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="builds" data-secondary="verifiable" data-see="verifiable builds" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="CAs" data-see="certificate authorities" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="certificate revocation" data-see="explicit revocation mechanism" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="CI/CD" data-see="continuous integration/continuous deployment" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="code" data-secondary="deploying" data-see="deploying code" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="code" data-secondary="testing" data-see="testing (code)" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="code" data-secondary="writing" data-see="writing code" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="complexity" data-secondary="managing" data-see="understandability" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="DDoS attacks" data-see="distributed denial-of-service attacks" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="encryption keys" data-see="key rotation" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="failure domains" data-see="distinct failure domains" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="IMAG" data-see="Incident Management at Google" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="incident management" data-see="crisis management; disaster planning" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="IR team" data-see="incident response team" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="mitigation strategies, advanced" data-see="advanced mitigation strategies" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="police" data-see="law enforcement agencies" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="proxies" data-secondary="safe" data-see="safe proxies (case study)" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="reliability" data-secondary="security and" data-see="intersection of security and reliability; tradeoffs, reliability/security" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="revocation mechanism" data-see="explicit revocation mechanism" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="rotation of keys" data-see="key rotation" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="RPCs" data-see="remote procedure calls" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="security (generally)" data-secondary="reliability and" data-see="intersection of security and reliability; tradeoffs, reliability/security" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="security changes" data-see="change, designing for" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="security experts" data-see="security specialists" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="security investigations" data-see="investigating systems" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="signing keys" data-see="key rotation" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="software development" data-see="testing (code); writing code" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="SRE" data-see="Site Reliability Engineer/Engineering" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="systems (generally)" data-secondary="investigating" data-see="investigating systems" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="TCB" data-see="trusted computing base" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="threat mitigation" data-see="advanced mitigation strategies" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="tradeoffs, design" data-see="design tradeoffs" data-type="indexterm">&nbsp;</a><a contenteditable="false" data-primary="validation, continuous" data-see="continuous validation" data-type="indexterm">&nbsp;</a></p>
</section>
</section>
</body>
</html>
<div data-type="footnotes">
<p data-type="footnote" id="ch01fn2"><sup><a href="#ch01fn2-marker">1</a></sup>For more information on error budgets, see <a class="orm:hideurl" href="https://landing.google.com/sre/sre-book/chapters/embracing-risk/">Chapter 3 in the SRE book</a>.</p>
</div>
